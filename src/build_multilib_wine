#!/bin/bash

#### AWK Function Definitions Block ####

# function process_literal_line
# 
# Description:
#   awk function to fix the scope of a single compound literal.
#   The argument may be a single line or a split line.
#
# shellcheck disable=SC2016
_WINE_AWK_FUNCTION_PROCESS_LITERAL_LINE=\
'function process_literal_line(line, offset, file_array,
		line_prefix, value, value_start,
		variable, variable_length, variable_start)
{
	match(file_array[line], idl_prefix_regex)
	if (RSTART) line_prefix=substr(file_array[line],RSTART,RLENGTH)
	match(file_array[line], define_regex)
	if (RSTART) variable_start=RSTART+RLENGTH
	match(file_array[line], define_variable_regex)
	if (RSTART) variable_length=(RSTART+RLENGTH-variable_start)
	match(file_array[line+offset], const_wchar_regex)
	if (RSTART) value_start=RSTART+RLENGTH
	if (!variable_start || !variable_length || !value_start)
		return 0
	variable=substr(file_array[line],variable_start,variable_length)
	value=substr(file_array[line+offset],value_start)
	if (offset) {
		file_array[line]=sprintf("%sstatic const WCHAR %s[] =\\",
			line_prefix, variable)
		file_array[line+offset]=sprintf("%*s%s",
			value_start, "", value)
	}
	else {
		file_array[line]=sprintf("%sstatic const WCHAR %s[] = %s",
			line_prefix, variable, value)
	}
	return 1
}'

# function is_broken_literal
#
# Description:
#   awk function predicate to test if line1 or (if line2 is specified)
#   line1+line2 contain a broken literal term.
#
# shellcheck disable=SC2016
_WINE_AWK_FUNCTION_IS_BROKEN_LITERAL=\
'function is_broken_literal(line1, line2,
		is_broken)
{
	is_broken=line2 && (line1 ~ (split_first_line_regex)) && (line2 ~ ("^" const_wchar_regex))
	is_broken=is_broken || ((line1 ~ header_line_regex) || (line1 ~ idl_line_regex))
	return is_broken
}'

# function process_source_file
#
# Description:
#   awk function to fix the scope of compound literals, in an array
#   which holds the entire contents of a source file.
#
# shellcheck disable=SC1004,SC2016
_WINE_AWK_FUNCTION_PROCESS_SOURCE_FILE=\
'function process_source_file(filename, file_array,
		changed_file, continuation_line, line, value_start)
{
	for (line=1 ; line<=file_array[0] ; ++line) {
		if (!(line in file_array)) continue
		if (is_broken_literal(file_array[line]))
			continuation_line=process_literal_line(line, 0, file_array)
		else if ((line<file_array[0]) && is_broken_literal(file_array[line], file_array[line+1]))
			continuation_line=process_literal_line(line, 1, file_array)
		if (!continuation_line) continue
		changed_file=1
		if (!sub(line_continuation_regex,"",file_array[line])) {
			continuation_line=!(sub("[\"][)]$",";&",file_array[line])\
				|| sub("[^;]$","&;",file_array[line]))
		}
	}
	return changed_file
}'

# function update_source_file
#
# Description:
#   awk function to rewrite the contents of a source file. Uses the argument
#   which holds the updated contents of the target source file.
#
# shellcheck disable=SC2016
_WINE_AWK_FUNCTION_UPDATE_SOURCE_FILE=\
'function update_source_file(filename, file_array,
		line)
{
	if (!file_array[0]) return
	printf(" * Updating %04d %s ...\n", ++file_count, filename)
	printf("") >filename
	for (line=1 ; line<=file_array[0] ; ++line)
		if (line in file_array) printf("%s\n", file_array[line]) >>filename
	printf(" [ ok ]\n")
}'

# AWK BEGIN-END block
#
# Description:
#   awk function to fix the scope of compound literal's.
#   Transforms:
#
#     #define LDAP_CONTROL_VLVRESPONSE_W (const WCHAR []){'2','.','1','6','.', \
#     '8','4','0','.','1','.','1','1','3','7','3','0','.','3','.','4','.','1','0',0}
#
#   into:
#
#     static const WCHAR LDAP_CONTROL_VLVRESPONSE_W[] = {'2','.','1','6','.',
#     '8','4','0','.','1','.','1','1','3','7','3','0','.','3','.','4','.','1','0',0};
#
#   See: https://www.gnu.org/software/gcc/gcc-9/porting_to.html#complit
#
# shellcheck disable=SC2016
_WINE_AWK_FIX_BLOCK_SCOPE_LITERALS=\
'BEGIN{
	const_wchar_regex="[[:blank:]][[:blank:]]*[(]const[[:space:]]*WCHAR[[:space:]]*[[][]][)]"
	define_regex="#[[:space:]]?define[[:blank:]][[:blank:]]*"
	define_variable_regex=(define_regex "[^[:blank:]]*")
	header_line_regex=("^" define_variable_regex const_wchar_regex)
	idl_prefix_regex=("^cpp_quote[(][\"]")
	idl_line_regex=(idl_prefix_regex define_variable_regex const_wchar_regex)
	line_continuation_regex="[[:blank:]]*[\\134\\134]$"
	split_first_line_regex=("^" define_variable_regex line_continuation_regex)
}
{
	if (filename != FILENAME) {
		if (filename && process_source_file(filename, file_array))
			update_source_file(filename, file_array)
		filename=FILENAME
		delete file_array
	}
	file_array[++file_array[0]]=$0
}
END{
	if (filename && process_source_file(filename, file_array))
		update_source_file(filename, file_array)
}'

#### General Helper Functions Definition Block ####

# function cleanup()
#
# Parameters:
#   [ 1>  : error_code : optional script exit error code         (integer) ]
#
# Description:
#   Clean up FIFO logging pipe, all Schroot sessions.
#   Compress log file (if logging is enabled) with specified compressor.
#   If no error code was specified kill the script in order to ensure it
#   shuts down completely. Otherwise exit with the specified error code.
#
function cleanup()
{
	local error_code=${1:-0} PGID

	sleep 1
	if [[ -p "${__FIFO_LOG_PIPE}" ]]; then
		rm "${__FIFO_LOG_PIPE}" &>/dev/null
	fi
	schroot -e -c "${SESSION_WINE_INITIALISE}" &>/dev/null
	schroot -e -c "${SESSION_WINE32}" &>/dev/null
	schroot -e -c "${SESSION_WINE64}" &>/dev/null
	if ((LOGGING)) && [[ -n "${COMPRESSOR_CMD}" && -n "${LOG}" && -f "${LOG}" ]]; then
		${COMPRESSOR_CMD} "${LOG}"
	fi
	if ((error_code)); then
		exit "${error_code}"
	else
		PGID="$( ps -o pgid "${SCRIPT_PID}" | gawk '{ if ($1 ~ /[[:digit:]]+/) print $1 }' )"
		kill -9 -"${PGID}" &>/dev/null
		exit
	fi
}

# function trap_exit()
#
# Parameters: <none>
#
# Description:
#   Traps multiple script exit conditions (force-quit, termination,
#   external kill, etc.) and calls function cleanup(), in order to ensure
#   a graceful exit condition is achieved.
#
function trap_exit()
{
	# shellcheck disable=SC2173
	trap '' ABRT INT QUIT TERM KILL STOP
	printf "\\n%s${FUNCNAME[ 0 ]} ()%s ... \\n" "${TTYRED_BOLD}" "${TTYRESET}"
	cleanup
}

# function die()
#
# Parameters:
#     1>  : error_message   : main error message to display  (string)
#     2>  : error_code (1*) : script exit error code         (integer)
#     3>  : usage (0*/1)    : display usage message          (boolean)
#
# Description:
#   Displays the specified error message and calling function name.
#   Optionally displays a script usage message.
#   Then this function calls the function cleanup(), to ensure a
#   graceful exit condition is achieved.
#
function die()
{
	local error_message="${1}"
	local error_code=${2:-1}
	local usage=${3:-0}
	local function_call="${FUNCNAME[1]}"

	# shellcheck disable=SC2173
	trap '' ABRT INT QUIT TERM KILL STOP
	[[ -p "${__FIFO_LOG_PIPE}" ]] && printf "%s" "${TTYRESET}"
	printf "%s" "${error_message}" | gawk \
						-vttycyan_bold="${TTYCYAN_BOLD}" -vttyred_bold="${TTYRED_BOLD}" -vttypurple_bold="${TTYPURPLE_BOLD}" \
						-vttygreen_bold="${TTYGREEN_BOLD}" -vttyreset="${TTYRESET}" \
						-vscript_name="${SCRIPT_NAME}" -vfunction_call="${function_call}"	-F'"' \
		'BEGIN{
			printf("%s%s%s : %s%s ()%s : ", ttygreen_bold, script_name, ttyreset, ttypurple_bold, function_call, ttyreset)
		}
		{
			for (i=1; i<=NF; ++i)
			{
				if (i%2 == 1)
					printf("%s%s%s", ttyred_bold, $i, ttyreset)
				else
					printf("%s\"%s%s%s\"", ttyreset, ttycyan_bold, $i, ttyreset)
			}
			printf("\n")
		}' >&2
	((usage)) 	&& usage_information >&2

	cleanup "${error_code}"
}

# function setup_tty_colours()
#
# Parameters:
#     1>  : enable_colour (0/1) : enable colourised terminal output  (boolean)
#
# Description:
#   If colour support is enabled (1) then generate global tty command codes,
#   for setting terminal colours, using the command tput. Otherwise, if colour
#   support is disabled (0), then set the global tty command codes to empty strings.
#
function setup_tty_colours()
{
	(($# == 1)) || die "Invalid parameter count: ${#} (1)"

	local enable_colour="${1}" output
	if ((enable_colour)); then
		output="/dev/stdout"
	else
		output="/dev/null"
	fi

	export	TTYRED
	export	TTYGREEN
	export	TTYYELLOW
	export	TTYBLUE
	export	TTYPURPLE
	export	TTYCYAN
	export	TTYWHITE
	export	TTYBOLD
	export	TTYRESET
	export	TTYRED_BOLD
	export	TTYGREEN_BOLD
	export	TTYYELLOW_BOLD
	export	TTYBLUE_BOLD
	export	TTYPURPLE_BOLD
	export	TTYCYAN_BOLD
	export	TTYWHITE_BOLD
	TTYRED="$( tput setaf 1 >${output} )"
	TTYGREEN="$( tput setaf 2 >${output} )"
	TTYYELLOW="$( tput setaf 3 >${output} )"
	TTYBLUE="$( tput setaf 4 >${output} )"
	TTYPURPLE="$( tput setaf 5 >${output} )"
	TTYCYAN="$( tput setaf 6 >${output} )"
	TTYWHITE="$( tput setaf 7 >${output} )"
	TTYBOLD="$( tput bold >${output} )"
	TTYRESET="$( tput sgr0 >${output} )"
	TTYRED_BOLD="${TTYRED}${TTYBOLD}"
	TTYGREEN_BOLD="${TTYGREEN}${TTYBOLD}"
	TTYYELLOW_BOLD="${TTYYELLOW}${TTYBOLD}"
	TTYBLUE_BOLD="${TTYBLUE}${TTYBOLD}"
	TTYPURPLE_BOLD="${TTYPURPLE}${TTYBOLD}"
	TTYCYAN_BOLD="${TTYCYAN}${TTYBOLD}"
	TTYWHITE_BOLD="${TTYWHITE}${TTYBOLD}"
}

# function pushd_wrapper()
#
# Parameters:
#     1>  : directory : directory to pass to pushd  (string)
#
# Description:
#   Colourises the pushd output and tests if the directory change
#   has succeeded.
#
function pushd_wrapper()
{
	(($# == 1)) || die "Invalid parameter count: ${#} (1)"

	local directory="${1}"

	printf "%s" "${TTYBLUE_BOLD}"
	pushd "${directory}" || die "pushd \"${directory}\" failed" $?
	printf "%s" "${TTYRESET}"
}

# function popd_wrapper()
#
# Parameters:
#   1>  : directory : directory to pass to popd  (string)
#
# Description:
#   Colourises the popd output and tests if the directory restoration
#   has succeeded.
#
function popd_wrapper()
{
	(($# == 0)) || die "Invalid parameter count: ${#} (0)"

	printf "%s" "${TTYBLUE_BOLD}"
	popd || die "popd failed" $?
	printf "%s" "${TTYRESET}"
}

# function set_wine_git_tag()
#
# Parameters:
#   [ 1>  : fail_on_error (1) : ignore or respond to errors  (string) ]
#
# Description:
#   Prioritise selection of the Wine git branch/commit/version (if specified):
#     1) Wine git branch
#     2) Wine git commit
#     3) Wine version
#   Disables the 2 other (unused) options.
#   The Wine version is converted to a Wine git tag.
#
function set_wine_git_tag()
{
	(($# <= 1)) || die "Invalid parameter count: ${#} (0-1)"

	local fail_on_error="${1:-1}" \
		wine_branch wine_branch_array wine_branch_valid=0

	# Setup Wine version to build
	if [[ -n "${WINE_BRANCH}" ]]; then
		WINE_BRANCH="${WINE_BRANCH#refs/heads/}"
		WINE_BRANCH="${WINE_BRANCH#refs/remotes/}"

		# shellcheck disable=SC2068
		for wine_branch in ${WINE_BRANCH_ARRAY[@]}; do
			[[ "${WINE_BRANCH}" == "${wine_branch}" ]] || continue

			wine_branch_valid=1
			export	__WINE_GIT_TAG="${WINE_BRANCH}"
			unset -v WINE_COMMIT WINE_VERSION
		done

		if ((!wine_branch_valid && fail_on_error)); then
			wine_branch_array="$( echo "${WINE_BRANCH_ARRAY[*]}" | sed "{s/^/'/;s/$/'/;s/ /'. '/g}" )"
			die "invalid WINE_BRANCH=\"${WINE_BRANCH}\" specified ( specify one of: ${wine_branch_array} )"
		fi
	elif [[ -n "${WINE_COMMIT}" ]]; then
		if [[ ! "${WINE_BRANCH}" =~ ${SHA1_REGEXP} ]]; then
			((fail_on_error)) && die "invalid WINE_COMMIT=\"${WINE_COMMIT}\" specified (SHA1 commit hash)"
		fi
		export	__WINE_GIT_TAG="${WINE_COMMIT}"
		unset -v WINE_VERSION
	else
		if [[ -z "${WINE_VERSION}" ]]; then
			((fail_on_error)) && die "No WINE_VERSION=\"${WINE_VERSION}\" specified"
		elif [[ ! "${WINE_VERSION}" =~ ${VERSION_REGEXP} ]]; then
			((fail_on_error)) && die "invalid WINE_VERSION=\"${WINE_VERSION}\" specified"
		fi
		export	__WINE_GIT_TAG="${WINE_PREFIX}${WINE_VERSION}"
	fi
}

# function set_wine_staging_git_tag()
#
# Parameters:
#   [ 1>  : fail_on_error (1) : ignore or respond to errors  (string) ]
#
# Description:
#   Prioritise selection of the Wine Staging git branch/commit/version (if specified):
#     1) Wine Staging git branch
#     2) Wine Staging git commit
#     3) Wine Staging version
#   Disables the 2 other (unused) options.
#   The Wine Staging version is converted to a Wine Staging git tag.
#
function set_wine_staging_git_tag()
{
	(($# <= 1)) || die "Invalid parameter count: ${#} (0-1)"

	local fail_on_error="${1:-1}" \
		wine_staging_branch wine_staging_branch_array wine_staging_branch_valid=0

	# Setup Wine-Staging version to build
	if [[ -n "${WINE_STAGING_BRANCH}" ]]; then
		WINE_STAGING_BRANCH="${WINE_STAGING_BRANCH#refs/heads/}"
		WINE_STAGING_BRANCH="${WINE_STAGING_BRANCH#refs/remotes/}"

		# shellcheck disable=SC2068
		for wine_staging_branch in ${WINE_STAGING_BRANCH_ARRAY[@]}; do
			[[ "${WINE_STAGING_BRANCH}" == "${wine_staging_branch}" ]] || continue

			wine_staging_branch_valid=1
			export	__WINE_STAGING_GIT_TAG="${WINE_STAGING_BRANCH}"
			unset -v WINE_STAGING_COMMIT WINE_STAGING_VERSION
		done

		if ((!wine_staging_branch_valid && fail_on_error)); then
			wine_staging_branch_array="$( echo "${WINE_STAGING_BRANCH_ARRAY[*]}" | sed "{s/^/'/;s/$/'/;s/ /'. '/g}" )"
			die "invalid WINE_STAGING_BRANCH=\"${WINE_STAGING_BRANCH}\" specified ( specify one of: ${wine_staging_branch_array} )"
		fi
	elif [[ -n "${WINE_STAGING_COMMIT}" ]]; then
		if [[ ! "${WINE_STAGING_COMMIT}" =~ ${SHA1_REGEXP} ]]; then
			((fail_on_error)) && die "invalid WINE_STAGING_COMMIT=\"${WINE_STAGING_COMMIT}\" specified (SHA1 commit hash)"
		fi
		export	__WINE_STAGING_GIT_TAG="${WINE_STAGING_COMMIT}"
		unset -v WINE_STAGING_VERSION
	else
		if [[ ! "${WINE_STAGING_VERSION}" =~ ${VERSION_REGEXP} ]]; then
			((fail_on_error)) && die "invalid WINE_STAGING_VERSION=\"${WINE_STAGING_VERSION}\" specified"
		fi
		if [[ "${WINE_STAGING_VERSION}" =~ 1\.8\.[1-9]*[0-9] ]]; then
			export	__WINE_STAGING_GIT_TAG="${WINE_STAGING_PREFIX}${WINE_STAGING_VERSION}${WINE_STAGING_SUFFIX}"
		else
			export	__WINE_STAGING_GIT_TAG="${WINE_STAGING_PREFIX}${WINE_STAGING_VERSION}"
		fi
		export	__WINE_GIT_TAG="${WINE_PREFIX}${WINE_STAGING_VERSION}"
	fi
}

# function parse_boolean_option()
#
# Parameters:
#     1>  __option       : boolean value description                (string)
#   [ 2<  __option_value : option variable to set to boolean value  (boolean, reference) ]
#
# Description:
#   Converts a boolean value string ("1", "0", "yes", "no", "true", "false")
#   to a simple boolean 0 / 1 value.
#   Open exit either: set the __option_value reference variable, or output, the
#   determined boolean value.
#
function parse_boolean_option()
{
	(((1 <= $#) && ($# <= 2))) || die "Invalid parameter count: ${#} (1-2)"

	local	__option="${1}" __option_name_reference="${2}"
	local	__valid_options="([1|0|yes|no|true|false])"
	local	__option_value

	if [[ -z "${__option}" ]]; then
		die "no ${__option_name_reference,,} option value specified ${__valid_options}" "" 1
	fi
	case "${__option}" in
		0|[Nn][Oo]|[Nn]|[Ff][Aa][Ll][Ss][Ee]|[Ff])
			__option_value=0;;
		1|[Yy][Ee][Ss]|[Yy]|[Tt][Rr][Uu][Ee]|[Tt])
			__option_value=1;;
		*)
			local __option_name="${__option_name_reference,,}"
			die "unknown ${__option_name//_/-} option value specified: \"${__option}\" ${__valid_options}" "" 1;;
	esac

	if [[ -z "${__option_name_reference}" ]]; then
		echo "${__option_value}"
	elif [[ "${__option_name_reference}" =~ ${VARIABLE_NAME_REGEXP} ]]; then
		declare -n option_name="${__option_name_reference}"
		# shellcheck disable=SC2034
		option_name="${__option_value}"
	else
		die "Parameter (3): invalid reference name (${VARIABLE_NAME_REGEXP}): '${__option_name_reference}'"
	fi
}

# function set_log_compression()
#
# Parameters:
#     1>  compressor       : compressor executable (or file extension)  (string)
#
# Description:
#   Converts a compressor executable or file extension to a command string to
#   use with that compressor. If the specified compressor is not installed then
#   exit with an error. The specified compressor will be used to compress the
#   script log file, when the script exits.
#
function set_log_compression()
{
	(($# == 1)) || die "Invalid parameter count: ${#} (1)"

	local compressor="${1}"
	case "${compressor}" in
		bzip2|bz2)
			command -v bzip2 &>/dev/null || die "bzip2 log compression unsupported - bzip2 compressor not detected"
			export COMPRESSOR_CMD="bzip2 -fq -9"
			;;
		gzip|gz)
			command -v gzip &>/dev/null || die "gzip log compression unsupported - gzip compressor not installed"
			export COMPRESSOR_CMD="gzip -fq -9"
			;;
		lzma)
			if command -v lzma &>/dev/null; then
				export COMPRESSOR_CMD="lzma -fq"
			elif command -v xz &>/dev/null; then
				export COMPRESSOR_CMD="xz --format=lzma -fq"
			else
				die "lzma log compression unsupported - neither of the lzma or xz compressors are installed"
			fi
			;;
		lzop)
			command -v lzop &>/dev/null || die "lzop log compression unsupported - lzop compressor not installed"
			export COMPRESSOR_CMD="lzop -fqU -9"
			;;
		lz4)
			command -v lz4 &>/dev/null || die "lz4 log compression unsupported - lz4 compressor not installed"
			export COMPRESSOR_CMD="lz4 -cfq -BD -9"
			;;
		xz)
			command -v xz &>/dev/null || die "xz log compression unsupported - xz compressor not installed"
			export COMPRESSOR_CMD="xz -fq"
			;;
		cat|none|no|disabled)
			export COMPRESSOR_CMD=""
			;;
		*)
			die "${compressor} compressor is unsupported"
			;;
	esac
}

# function logging_thread()
#
# Parameters: <none>
#
# Description:
#   Runs as background thread. Writes data from the output of FIFO pipe
#   (which the main script writes into) and outputs this stdout. If
#   logging is enabled then store this FIFO data in a log file as well.
#
function logging_thread()
{
	# shellcheck disable=SC2173
	trap "cleanup" ABRT INT QUIT TERM KILL STOP
	while [[ -p "${__FIFO_LOG_PIPE}" ]]; do
		((LOGGING))		&& cat < "${__FIFO_LOG_PIPE}" | tee -a "${LOG}"
		((LOGGING))		|| cat < "${__FIFO_LOG_PIPE}"
	done
	printf "\\n%sLogging completed!!%s\\n" "${TTYYELLOW_BOLD}" "${TTYRESET}"
}

# setup_logging()
#	1>	: main script command being executed
function setup_logging()
{
	(($# == 1)) || die "Invalid parameter count: ${#} (1)"

	local command="${1}" git_branch

	mkfifo -m=600 "${__FIFO_LOG_PIPE}" &>/dev/null || die "mkfifo \"${__FIFO_LOG_PIPE}\" failed" $?
	# Use a FIFO to compress all log file output in a background shell
	if ((LOGGING)); then
		# Make Log directory
		LOG=$(date --iso-8601=seconds)
		case "${command}" in
			setup)
				export LOG="${LOG_DIRECTORY}/chroot-setup_${LOG}.log";;
			upgrade)
				export LOG="${LOG_DIRECTORY}/chroot-upgrade_${LOG}.log";;
			build)
				if ((WINE_STAGING)); then
					[[ -n "${WINE_STAGING_BRANCH}" ]] && git_branch="${WINE_STAGING_BRANCH//\//-}"
					export LOG="${LOG_DIRECTORY}/wine-staging-${git_branch:-${WINE_STAGING_COMMIT:-${WINE_STAGING_VERSION}}}_${LOG}.log"
				else
					[[ -n "${WINE_BRANCH}" ]] && git_branch="${WINE_BRANCH//\//-}"
					export LOG="${LOG_DIRECTORY}/wine-${git_branch:-${WINE_COMMIT:-${WINE_VERSION}}}_${LOG}.log"
				fi;;
			*)
				die "Invalid command specified"
		esac
		[[ -d "${LOG_DIRECTORY}" ]] || mkdir -p "${LOG_DIRECTORY}" &>/dev/null
		rm "${LOG}" &>/dev/null
		printf "%s\\n" "${TTYCYAN_BOLD}Finished setting up FIFO logging using: ${TTYBLUE_BOLD}${LOG}${TTYRESET}"
	else
		printf "%s\\n" "${TTYCYAN_BOLD}Logging disabled${TTYRESET}"
	fi

	logging_thread &
	__LOGGING_PID=$!
}

# function set_lsb_codename()
#
# Parameters: <none>
#
# Description:
#   If the global variable: LSB_CODENAME ; is unset, then sets this,
#   as a function side effect, to the Host System LSB codename (lowercase).
#   The function also has a block to reverse-mangle the stupid Linux Mint
#   release code name overrides...
#
function set_lsb_codename()
{
	if [[ -z "${LSB_CODENAME}" ]]; then
		LSB_CODENAME="$(lsb_release -sc)"
		LSB_CODENAME="${LSB_CODENAME,,}"
	fi

	case "${LSB_CODENAME}" in
		# Linux Mint Main Edition (newer first)
		ulyana)
			LSB_CODENAME="focal";;
		tara|tessa|tina|tricia)
			LSB_CODENAME="bionic";;
		sylvia|sonya|serena|sarah)
			LSB_CODENAME="xenial";;
		rosa|rafaela|rebecca|qiana)
			LSB_CODENAME="trusty";;
		# LMDE (newer first)
		cindy)
			LSB_CODENAME="stretch";;
		betsy)
			LSB_CODENAME="jessie";;
		# elementary OS (newer first)
		juno)
			LSB_CODENAME="bionic";;
		loki)
			LSB_CODENAME="xenial";;
		freya)
			LSB_CODENAME="trusty";;
	esac
}

# function set_lsb_distribution_id()
#
# Parameters: <none>
#
# Description:
#   Sets the global variable: LSB_DISTRIBUTION_ID ; to match the chroot
#   LSB codename global variable: LSB_CODENAME.
#
function set_lsb_distribution_id()
{
	case "${LSB_CODENAME}" in
		trusty|xenial|bionic|cosmic|disco|eoan|focal)
			LSB_DISTRIBUTION_ID="ubuntu"
			;;
		*)
			LSB_DISTRIBUTION_ID="debian"
			;;
	esac
}

# function fetch_wine_staging_patchbin()
#
# Parameters:
#     1>  __scripts_directory : directory to download script to  (string)
#
# Description:
#   Downloads the Wine Staging gitapply.sh script from Github.
#   Update the usage information, to reflect the scripts name change.
#
function fetch_wine_staging_patchbin_script()
{
	(($# == 1)) || die "Invalid parameter count: ${#} (1)"

	local __scripts_directory="${1}"
	if [[ ! -d "${__scripts_directory}" ]]; then
		die "Script download directory does not exist: \"${__scripts_directory}\""
	fi

	pushd_wrapper "${__scripts_directory}"
	wget -O "${WINE_STAGING_PATCHBIN_SCRIPT}" "${WINE_STAGING_BINPATCH_URI}" \
		|| die "wget failed: unable to download Wine Staging gitapply.sh script: \"${WINE_STAGING_BINPATCH_URI}\""
	sed -E -i "s/(\\.\\/)?gitapply(\\.sh)?/${WINE_STAGING_PATCHBIN_SCRIPT}/g" "${WINE_STAGING_PATCHBIN_SCRIPT}" \
		|| die "sed failed: patching Wine Staging gitapply.sh (${WINE_STAGING_PATCHBIN_SCRIPT}) script"
	chmod +x "${WINE_STAGING_PATCHBIN_SCRIPT}" \
		|| die "chmod +x failed"
	popd_wrapper
}

# check_package_dependencies()
# function fetch_wine_staging_patchbin()
#
# Parameters: <none>
#
# Description:
#   Checks that the base package dependencies, required by this script, are
#   installed on the host system. Exit the script, if any are not present.
#
function check_package_dependencies()
{
	(($# == 0)) || die "Invalid parameter count: ${#} (0)"

	local -a array_executables=(
		"bzip2" "debootstrap" "gawk" "git" "lsb_release" "md5sum" "mkfifo" "rsync" "schroot" "sed" "wget"
	)
	local executable

	if [[ "${LSB_DISTRIBUTION_ID}" == "debian" ]]; then
		array_executables+=("netselect-apt")
		export PATH="/usr/local/sbin:/usr/sbin:/sbin:${PATH}"
	fi

	for executable in "${array_executables[@]}"; do
		command -v "${executable}" &>/dev/null &&	continue

		case "${executable}" in
			md5sum|mkfifo)
				package_list="${package_list} coreutils";;
			*)
				package_list="${package_list} ${executable}";;
		esac
	done
	if [[ -n "${package_list}" ]]; then
		printf "sudo apt-get install %s${package_list}%s\\n" "${TTYCYAN}" "${TTYRESET}" >&2
	fi
	[[ -z "${package_list}" ]] || die "please install the (above) required package(s) and re-run this script"
}

# function usage_information()
#
# Parameters: <none>
#
# Description:
#   Displays a full (optionally colourised) description of all the commands
#   and options that can be used with this script.
#
function usage_information()
{
	(($# == 0)) || die "Invalid parameter count: ${#} (0)"

	local indent=-2 col_width=-15 gopt_col_width=-20

	printf "Usage:\\n"
	printf "%*s%s%s%s  [%sGLOBAL-OPTION%s(s)] %ssetup-chroot%s\\n" \
		${indent} "" "${TTYPURPLE_BOLD}" "${SCRIPT_NAME}" "${TTYRESET}" "${TTYGREEN}" "${TTYRESET}" "${TTYCYAN_BOLD}" "${TTYRESET}"
	printf "%*s%s%s%s  [%sGLOBAL-OPTION%s(s)] %supgrade-chroot%s\\n" \
		${indent} "" "${TTYPURPLE_BOLD}" "${SCRIPT_NAME}" "${TTYRESET}" "${TTYGREEN}" "${TTYRESET}" "${TTYCYAN_BOLD}" "${TTYRESET}"
	printf "%*s%s%s%s  [%sGLOBAL-OPTION%s(s)] [%sBUILD-OPTION%s(s)] %ssrc-fetch | src-prepare | src-configure | src-compile | src-install%s\\n" \
		${indent} "" "${TTYPURPLE_BOLD}" "${SCRIPT_NAME}" "${TTYRESET}" "${TTYGREEN}" "${TTYRESET}" "${TTYYELLOW}" "${TTYRESET}" "${TTYCYAN_BOLD}" "${TTYRESET}"
	printf "%*s%s%s%s  [%sGLOBAL-OPTION%s(s)] [%sBUILD-OPTION%s(s)] %sbuild-all%s\\n\\n" \
		${indent} "" "${TTYPURPLE_BOLD}" "${SCRIPT_NAME}" "${TTYRESET}" "${TTYGREEN}" "${TTYRESET}" "${TTYYELLOW}" "${TTYRESET}" "${TTYCYAN_BOLD}" "${TTYRESET}"

	printf "Utility to build dual-architecture, multilib Wine on Debian or Ubuntu(tm).\\n"
	printf "Uses dual (32-bit and 64-bit) Chroot (schroot) Environments.\\n\\n"
	printf "Consecutive build phases can be selected, chained, and re-run.\\n\\n"

	printf "%scommand%s(s) :\\n" "${TTYCYAN_BOLD}" "${TTYRESET}"
	printf "\\n"
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYCYAN_BOLD}" ${col_width} "generate-conf" "${TTYRESET}" ${indent} "" "Generate default:"
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYCYAN_BOLD}" ${col_width} "" "${TTYRESET}" ${indent} "" "  \"${SCRIPT_CONFIG}\""
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYCYAN_BOLD}" ${col_width} "" "${TTYRESET}" ${indent} "" "- configuration file."
	printf "\\n"
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYCYAN_BOLD}" ${col_width} "setup-chroot" "${TTYRESET}" ${indent} "" "Setup 32-bit and 64-bit Chroot Environments."
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYCYAN_BOLD}" ${col_width} "" "${TTYRESET}" ${indent} "" "Install Debian/Ubuntu base development libraries for Wine"
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYCYAN_BOLD}" ${col_width} "" "${TTYRESET}" ${indent} "" "in the dual Chroot Environments. "
	printf "%*s%s%*s%s%*s%s%s%s\\n" \
		$((indent)) "" "${TTYCYAN_BOLD}" ${col_width} "" "${TTYRESET}" ${indent} "" "${TTYRED}" "This command runs as root." "${TTYRESET}"
	printf "\\n"
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYCYAN_BOLD}" ${col_width} "upgrade-chroot" "${TTYRESET}" ${indent} "" "Upgrade Debian/Ubuntu base development libraries for Wine"
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYCYAN_BOLD}" ${col_width} "" "${TTYRESET}" ${indent} "" "in the dual Chroot Environments. "
	printf "%*s%s%*s%s%*s%s%s%s\\n" \
		$((indent)) "" "${TTYCYAN_BOLD}" ${col_width} "" "${TTYRESET}" ${indent} "" "${TTYRED}" "This command runs as root." "${TTYRESET}"
	printf "\\n"
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYCYAN_BOLD}" ${col_width} "version" "${TTYRESET}" ${indent} "" "Display build version of ${SCRIPT_NAME} ."
	printf "\\n\\n"
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent-6)) "(${SRC_FETCH})" "${TTYCYAN_BOLD}" ${col_width} "src-fetch" "${TTYRESET}" ${indent} "" "Run (Git) source fetch phase."
	printf "\\n"
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent-6)) "(${SRC_PREPARE})" "${TTYCYAN_BOLD}" ${col_width} "src-prepare" "${TTYRESET}" ${indent} "" "Run source preparation (patching) phase."
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent-6)) "" "${TTYCYAN_BOLD}" ${col_width} "" "${TTYRESET}" ${indent} "" "If building Wine-Staging - the Staging patches will be"
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent-6)) "" "${TTYCYAN_BOLD}" ${col_width} "" "${TTYRESET}" ${indent} "" "applied during this phase."
	printf "\\n"
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent-6)) "(${SRC_CONFIGURE})" "${TTYCYAN_BOLD}" ${col_width} "src-configure" "${TTYRESET}" ${indent} "" "Run source configuration phase."
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent-6)) "" "${TTYCYAN_BOLD}" ${col_width} "" "${TTYRESET}" ${indent} "" "This phase is executed in the dual Chroot Environments."
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent-6)) "" "${TTYCYAN_BOLD}" ${col_width} "" "${TTYRESET}" ${indent} "" "Phase includes a make clean operation (if required)."
	printf "\\n"
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent-6)) "(${SRC_COMPILE})" "${TTYCYAN_BOLD}" ${col_width} "src-compile" "${TTYRESET}" ${indent} "" "Run source compilation phase."
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent-6)) "" "${TTYCYAN_BOLD}" ${col_width} "" "${TTYRESET}" ${indent} "" "This phase is executed in the dual Chroot Environments."
	printf "\\n"
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent-6)) "(${SRC_INSTALL})" "${TTYCYAN_BOLD}" ${col_width} "src-install" "${TTYRESET}" ${indent} "" "Run installation phase."
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent-6)) "" "${TTYCYAN_BOLD}" ${col_width} "" "${TTYRESET}" ${indent} "" "This phase is executed in the dual Chroot Environments."

	printf "\\n"
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent-6)) "(${SRC_FETCH})-(${SRC_INSTALL})" "${TTYCYAN_BOLD}" ${col_width} "build-all" "${TTYRESET}" ${indent} "" "Specifies that all phases (see above)"
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent-6)) "" "${TTYCYAN_BOLD}" ${col_width} "" "${TTYRESET}" ${indent} "" "will be executed in a chain."
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent-6)) "" "${TTYCYAN_BOLD}" ${col_width} "" "${TTYRESET}" ${indent} "" "Note: multiple phases can also be specified"
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent-6)) "" "${TTYCYAN_BOLD}" ${col_width} "" "${TTYRESET}" ${indent} "" "individually and these will be chained together."
	printf "%sGLOBAL-OPTION%s :\\n" "${TTYGREEN}" "${TTYRESET}"
	printf "\\n"
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYGREEN}" ${gopt_col_width} "--colour[=][y|n|yes|no] | -c[=][y|n|yes|no] " "${TTYRESET}" ${indent} "" ""
	printf "%*s%s%*s%s%*s%s\\n\\n" \
		$((indent)) "" "${TTYGREEN}" ${gopt_col_width} "" "${TTYRESET}" ${indent} "" "Enable/disable colourised console output. [default=no]"
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYGREEN}" ${gopt_col_width} "--logging[=][y|n|yes|no]" "${TTYRESET}" ${indent} "" ""
	printf "%*s%s%*s%s%*s%s\\n\\n" \
		$((indent)) "" "${TTYGREEN}" ${gopt_col_width} "" "${TTYRESET}" ${indent} "" "Enable/disable logging of operations.	 [default=yes]"
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYGREEN}" ${gopt_col_width} "--log-compression[=][bzip2|gzip|lzma|lzop|none|lz4|xz]" "${TTYRESET}" ${indent} "" ""
	printf "%*s%s%*s%s%*s%s\\n\\n" \
		$((indent)) "" "${TTYGREEN}" ${gopt_col_width} "" "${TTYRESET}" ${indent} "" "Specify (optional) log file compression.  [default=gzip]"
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYGREEN}" ${gopt_col_width} "--log-directory" "${TTYRESET}" ${indent} "" "Specify directory in which log files will be created during build."
	printf "\\n"
	printf "%sBUILD-OPTION%s :\\n" "${TTYYELLOW}" "${TTYRESET}"
	printf "\\n"
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYYELLOW}" ${gopt_col_width} "--wine-staging[=][y|n|yes|no]" "${TTYRESET}" ${indent} "" ""
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYYELLOW}" ${gopt_col_width} "" "${TTYRESET}" ${indent} "" "Specify whether to build Wine or Wine-Staging."
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYYELLOW}" ${gopt_col_width} "--wine-branch[=]branch" "${TTYRESET}" ${indent} "" ""
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYYELLOW}" ${gopt_col_width} "" "${TTYRESET}" ${indent} "" "Specify Wine Git branch to build."
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYYELLOW}" ${gopt_col_width} "--wine-commit[=]SHA-1 commit hash" "${TTYRESET}" ${indent} "" ""
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYYELLOW}" ${gopt_col_width} "" "${TTYRESET}" ${indent} "" "Specify Wine Git commit to build."
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYYELLOW}" ${gopt_col_width} "" "${TTYRESET}" ${indent} "" "Use 40 character hexidecimal SHA-1 hash."
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYYELLOW}" ${gopt_col_width} "--wine-version[=]numeric-version" "${TTYRESET}" ${indent} "" ""
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYYELLOW}" ${gopt_col_width} "" "${TTYRESET}" ${indent} "" "Specify Wine version to build."
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYYELLOW}" ${gopt_col_width} "" "${TTYRESET}" ${indent} "" "Use numeric version string (e.g. 1.9.20 1.8.5-rc1)"
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYYELLOW}" ${gopt_col_width} "--wine-staging-branch[=]branch" "${TTYRESET}" ${indent} "" ""
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYYELLOW}" ${gopt_col_width} "" "${TTYRESET}" ${indent} "" "Specify Wine-Staging Git branch to build."
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYYELLOW}" ${gopt_col_width} "--wine-staging-commit[=]SHA-1 commit hash" "${TTYRESET}" ${indent} "" ""
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYYELLOW}" ${gopt_col_width} "" "${TTYRESET}" ${indent} "" "Specify Wine-Staging Git commit to build."
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYYELLOW}" ${gopt_col_width} "" "${TTYRESET}" ${indent} "" "Use 40 character hexidecimal SHA-1 hash."
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYYELLOW}" ${gopt_col_width} "--wine-staging-version[=]numeric-version" "${TTYRESET}" ${indent} "" ""
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYYELLOW}" ${gopt_col_width} "" "${TTYRESET}" ${indent} "" "Specify Wine-Staging version to build."
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYYELLOW}" ${gopt_col_width} "" "${TTYRESET}" ${indent} "" "Use numeric version string (e.g. 1.9.20 1.8.5)"
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYYELLOW}" ${gopt_col_width} "--build-directory" "${TTYRESET}" ${indent} "" "Specify build (binaries) target directory."
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYYELLOW}" ${gopt_col_width} "--patch-directory" "${TTYRESET}" ${indent} "" "Specify directory containing user patch files."
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYYELLOW}" ${gopt_col_width} "" "${TTYRESET}" ${indent} "" "Can be specified more than once."
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYYELLOW}" ${gopt_col_width} "--source-directory" "${TTYRESET}" ${indent} "" "Specify directory to store source files."
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYYELLOW}" ${gopt_col_width} "" "${TTYRESET}" ${indent} "" "Note: this can be specified more than once."
	printf "%*s%s%*s%s%*s%s\\n" \
		$((indent)) "" "${TTYYELLOW}" ${gopt_col_width} "--prefix" "${TTYRESET}" ${indent} "" "Specify prefix directory for installation phase."
	printf "\\n"
}

# display_completion_message()
function display_completion_message()
{
	(($# == 0)) || die "Invalid parameter count: ${#} (0)"

	if [[ "${COMMAND}" == "setup" || "${COMMAND}" == "upgrade" ]]; then
		printf "\\n%s%s%s: %sChroot ${COMMAND}, has completed successfully%s ...\\n" \
			"${TTYGREEN_BOLD}" "${SCRIPT_NAME}" "${TTYRESET}" "${TTYWHITE}" "${TTYRESET}"
	elif [[ "${COMMAND}" == "conf" ]]; then
		printf "\\n%s%s%s: %sGenerate configuration file. has completed successfully%s ...\\n" \
			"${TTYGREEN_BOLD}" "${SCRIPT_NAME}" "${TTYRESET}" "${TTYWHITE}" "${TTYRESET}"
	elif [[ "${COMMAND}" == "build" ]]; then
		local	-a build_phases=("" "src-fetch" "src-prepare" "src-configure" "src-compile" "src-install")

		local phases_completed=""
		local i count=0
		for (( i=SRC_FETCH ; i<=SRC_INSTALL ; ++i)); do
			((SUBCOMMANDS[i]))	|| continue

			phases_completed="${phases_completed},${build_phases[i]}"
			: $((++count))
		done
		((count==1)) && phases_completed="Build phase: ${phases_completed:1}; has completed successfully, "
		((count!=1)) && phases_completed="Build phases: ${phases_completed:1}; have completed successfully, "
		((WINE_STAGING))	|| local	wine_version="${__WINE_VERSION}"
		((WINE_STAGING))	&& local	wine_version="(Staging) ${__WINE_STAGING_VERSION}"
		printf "\\n%s%s%s: %s${phases_completed} for Wine ${wine_version}%s ...\\n" \
				"${TTYGREEN_BOLD}" "${SCRIPT_NAME}" "${TTYRESET}" "${TTYWHITE}" "${TTYRESET}"
	fi
}

#### Build Helper Functions Definition Block ####

# function fetch_and_extract_tarball()
#
# Parameters:
#     1>  __directory    : target directory to extract to ("."=PWD)  (string)
#     2>  __download_uri : download URI for tarball                  (string)
#   [ 3>  __tarball      : rename tarball                            (string) ]
#
# Description:
#   Downloads a tarball, from the specified URL. Optionally rename the downloaded
#   tarball. Extracts the tarball within the specified directory.
#
function fetch_and_extract_tarball()
{
	(( ($# == 2) || ($# == 3) )) || die "Invalid parameter count: ${#} (2-3)"
	local __directory="${1:-.}" __download_uri="${2}" __tarball
	if (($# == 3)); then
		__tarball="${3}"
	else
		__tarball="$(basename "${__download_uri}")"
	fi
	[[ "${__directory}" != "." ]] && pushd_wrapper "${__directory}"
	wget -O "${__tarball}" "${__download_uri}" || die "wget \"${__download_uri}\" failed"
	tar xvfa "${__tarball}" || die "tar e(x)tract failed"
	rm "${__tarball}" || die "rm failed"
	[[ "${__directory}" != "." ]] && popd_wrapper
}

# function create_main_directories()
#
# Parameters:
#     1[-N]>  __directory [... __directory]  : directories to create  (string array)
#
# Description:
#   For each directory (__directory), in the function argument(s)...
#   If the directory does not pre-exist, then create it.
#
function create_main_directories()
{
	(($# >= 1)) || die "Invalid parameter count: ${#} (1-)"

	local directory

	for directory; do
		printf "directory='%s'\\n" "${directory}"
		[[ -d "${directory}" ]] && continue

		mkdir -p "${directory}" || die "mkdir -p \"${directory}\" failed"
	done
}

# function clean_source_directories()
#
# Parameters:
#     1[-N]>  __directory [... __directory]  : directories to clean  (string array)
#
# Description:
#   For each directory (__directory), in the function argument(s)...
#   If the directory exists, then delete the directory and all subdirectories.
#
clean_source_directories()
{
	(($# >= 1)) || die "Invalid parameter count: ${#} (1-)"

	local -a directories_array=( "${@}" )
	local i
	for i in ${!directories_array[*]}; do
		[[ -d "${directories_array[i]}" ]] || continue

		rm -rf "${directories_array[i]}" \
				|| die "rm -rf \"${directories_array[i]}\" failed"
	done
}

# function fetch_and_extract_tarball()
#
# Parameters:
#     1[-N]>  directories_array : build directories to wipe  (string array)
#
# Description:
#   Wipes all files and subdirectories from the specified directories_array.
#   If any build directories do not exist, then create them instead.
#
clean_build_directories()
{
	(($# >= 1)) || die "Invalid parameter count: ${#} (1-)"

	local -a directories_array=( "${@}" )
	local i
	for i in ${!directories_array[*]}; do
		if [[ -d "${directories_array[i]}" ]]; then
			rm -rf "${directories_array[i]:?}"/* \
				|| die "rm -rf \"${directories_array[i]}\"/* failed"
		else
			mkdir -p "${directories_array[i]}" \
				|| die "mkdir -p \"${directories_array[i]}\" failed"
		fi
	done
}

# function git_clone()
#
# Parameters:
#   [ 1>  git_directory      : rename cloned git directory  (string) ]
#     2>  git_repository_uri : full URI for git repository  (string)
#
# Description:
#   Clones the specified git repository to the current sources root
#   directory. Optionally rename the cloned git repository directory
#   to git_directory.
#
function git_clone()
{
	(((1 <= $#) && ($# <= 2))) || die "Invalid parameter count: ${#} (1-2)"

	# shellcheck disable=SC2124
	local git_directory="${SOURCE_ROOT}/${1}" git_repository_uri="${@: -1:1}"

	if (($# == 1)); then
		git_directory="${git_repository_uri##*/}"
		git_directory="${SOURCE_ROOT}/${git_directory%.*}"
	fi
	[[ -d "${git_directory}/.git" ]] && return 0

	printf "%s\\n" "${TTYCYAN_BOLD}Cloning \"${TTYBLUE_BOLD}${git_repository_uri}${TTYRESET}\" into ${TTYBLUE_BOLD}${git_directory}${TTYRESET} ..."
	git clone "${git_repository_uri}" \
		|| die "git clone \"${git_repository_uri}\" failed (\"${1}\")" $?
}

# function git_pull()
#
# Parameters:
#     1>  git_directory : git directory, under sources root  (string)
#
# Description:
#   For the specified git repository (git_directory) ensure we are on the
#   master branch, clean and reset the git tree. Then perform a git pull request.
#
function git_pull()
{
	(($# == 1)) || die "Invalid parameter count: ${#} (1)"

	local git_directory="${SOURCE_ROOT}/${1}"

	pushd_wrapper "${git_directory}"
	git clean -xdfq || die "git clean -xdfq failed (\"${1}\")" $?
	git reset --hard HEAD || die "git reset --hard HEAD failed (\"${1}\")" $?
	git checkout "master" || die "git checkout \"master\" failed (\"${1}\")" $?
	git clean -xdfq || die "git clean -xdfq failed (\"${1}\")" $?
	git reset --hard "origin/master"  || die "git reset --hard \"master\" failed (\"${1}\")" $?
	git pull || die "git pull failed (\"${1}\")" $?
	popd_wrapper
}

# function git_set_tag()
#
# Parameters:
#     1>  git_directory  : git directory, under sources root  (string)
#     2>  git_tag        : git commit, branch, or tag         (string)
#
# Description:
#   For the specified git repository (git_directory) clean the git tree.
#   Then reset the current branch to the specified
#   git_tag (git commit, branch, or tag).
#
function git_set_tag()
{
	(($# == 2)) || die "Invalid parameter count: ${#} (2)"

	local git_directory="${SOURCE_ROOT}/${1}" git_tag="${2}"

	pushd_wrapper "${git_directory}"
	git clean -xdfq || die "git clean -xdfq failed (\"${1}\")" $?
	git reset --hard "${git_tag}" || die "git reset --hard \"${git_tag}\" failed (\"${1}\")" $?
	popd_wrapper
}

# function git_get_commit()
#
# Parameters:
#     1>  __git_directory        : git directory, under sources root  (string)
#   [ 2<  __git_commit_reference : git commit                         (string, reference) ]
#
# Description:
#   For the specified git repository (git_directory) obtain the git commit for
#   the branch HEAD. If the __git_commit_reference variable is specified use this
#   to return the determined git commit. Otherwise output the git commit to stdout.
#
function git_get_commit()
{
	(((1 <= $#) && ($# <= 2))) || die "Invalid parameter count: ${#} (1-2)"

	local	__git_directory="${SOURCE_ROOT}/${1}" __git_commit_reference="${2}" __git_commit

	pushd_wrapper "${__git_directory}"
	__git_commit=$(git rev-parse HEAD)
	[[ "${__git_commit}" =~ ${SHA1_REGEXP} ]] || die "git rev-parse HEAD failed (\"${1}\")"
	popd_wrapper

	if [[ -z "${__git_commit_reference}" ]]; then
		echo "${__git_commit}"
	elif [[ "${__git_commit_reference}" =~ ${VARIABLE_NAME_REGEXP} ]]; then
		declare -n git_commit="${__git_commit_reference}"
		# shellcheck disable=SC2034
		git_commit="${__git_commit}"
	else
		die "Parameter (2): invalid reference name (${VARIABLE_NAME_REGEXP}): '${__git_commit_reference}'"
	fi
}

# function git_get_branch_list()
#
# Parameters:
#     1 >  __git_directory               : git directory         (string)
#   [ 2<   __git_branch_list_reference   : git commit list       (string array, reference) ]
#
# Description:
#   Returns all git branches, from the git repository, located in the specified git
#   directory (__git_directory).
#   Git branches are either returned in the reference variable: __git_branch_list_reference ;
#   or via stdout.
#
function git_get_branch_list()
{
	(((1 <= $#) && ($# <= 2))) || die "Invalid parameter count: ${#} (1-2)"

	local	__git_directory="${SOURCE_ROOT%/}/${1}" \
			__git_branch_array_reference="${2}" \
			__git_branch_list
	local	-a __git_branch_array=()

	if pushd "${__git_directory}" &>/dev/null; then
		__git_branch_list="$(
			git branch -a --format '%(refname)' \
			|  awk  '{ if (sub("^refs/(heads|remotes)/", "") && ($0 != "%(refname)")) print $0 }'
		)" || die "git branch failed"
		readarray -t __git_branch_array <<< "${__git_branch_list}"
		# shellcheck disable=SC2164
		popd &>/dev/null
	fi

	((${#__git_branch_array[@]})) || return 1

	if [[ -z "${__git_branch_array_reference}" ]]; then
		echo "${__git_branch_array[@]}"
	elif [[ "${__git_branch_array_reference}" =~ ${VARIABLE_NAME_REGEXP} ]]; then
		# shellcheck disable=SC2178
		declare -n git_branch_array="${__git_branch_array_reference}"
		# shellcheck disable=SC2034
		git_branch_array=( "${__git_branch_array[@]}" )
	else
		die "Parameter (2): invalid reference name (${VARIABLE_NAME_REGEXP}): '${__git_branch_array_reference}'"
	fi
}

# function git_get_tag()
#
# Parameters:
#     1>  __git_directory     : git directory, under sources root  (string)
#   [ 2<  __git_tag_reference : git tag                            (string, reference) ]
#
# Description:
#   For the specified git repository (__git_directory) obtain the git tag for
#   the branch HEAD. If the __git_tag_reference variable is specified use this
#   to return the determined git tag. Otherwise output the git tag to stdout.
#
function git_get_tag()
{
	(((1 <= $#) && ($# <= 2))) || die "Invalid parameter count: ${#} (1-2)"

	local	__git_directory="${SOURCE_ROOT}/${1%/}" __git_tag_reference="${2}" __git_tag

	pushd_wrapper "${__git_directory}"
	__git_tag=$(git describe --abbrev=0 --tags || die "git describe --abbrev=0 --tags failed")
	popd_wrapper

	if [[ -z "${__git_tag_reference}" ]]; then
		echo "${__git_tag}"
	elif [[ "${__git_tag_reference}" =~ ${VARIABLE_NAME_REGEXP} ]]; then
		declare -n git_tag="${__git_tag_reference}"
		# shellcheck disable=SC2034
		git_tag="${__git_tag}"
	else
		die "Parameter (2): invalid reference name (${VARIABLE_NAME_REGEXP}): '${__git_tag_reference}'"
	fi
}

# function git_is_commit_in_range()
#
# Parameters:
#     1>  __git_directory      : git directory, under sources root  (string)
#     2>  __commit_range_start : git commit (start of range)        (string)
#     3>  __commit_range_end   : git commit (end of range)          (string)
#      <  0 / 1                : in range / not in range            (boolean)
# Description:
#   For the specified git repository (__git_directory) check if the branch HEAD
#   commit falls within the git commit range:
#     [__commit_range_start,__commit_range_end)
#   Returns: 0 / 1 (in range / not in range)
#
git_is_commit_in_range() {
	(($# == 3))	|| die "invalid parameter count: ${#} (3)"

	local	 __git_directory="${SOURCE_ROOT}/${1%/}"  __commit_range_start="${2}" \
				__commit_range_end="${3}" __in_commit_range

	if [[ ! -d "${__git_directory}/.git" ]]; then
		die "argument (1): path \"${__git_directory}\" is not a valid Git repository directory"
	elif [[ ! "${__commit_range_start}" =~ ${SHA1_REGEXP} ]]; then
		die "argument (2):  is not a valid git commit (${__commit_range_start})"
	elif [[ ! "${__commit_range_end}" =~ ${SHA1_REGEXP} ]]; then
		die "argument (3): is not a valid git commit (${__commit_range_end})"
	fi

	pushd_wrapper "${__git_directory}"
	if 			git merge-base --is-ancestor "${__commit_range_start}"	HEAD \
		&& ! 	git merge-base --is-ancestor "${__commit_range_end}"	HEAD; then
		__in_commit_range=1
	else
		__in_commit_range=0
	fi
	popd_wrapper
	return $((!__in_commit_range))
}

# function wine_staging_get_upstream_commit()
#
# Parameters:
#     1>  __git_directory           : git directory, under sources root  (string)
#     2>  __wine_staging_git_commit : Wine Staging git commit            (SHA1 string)
#   [ 3<  __git_commit_reference    : Wine (Upstream) git commit         (SHA1 string) ]
#
# Description:
#   For the specified Wine Staging git repository (__git_directory): run the
#   patchinstall.sh script to determine the Upstream Wine git commit
#   (__git_commit_reference), corresponding to the current Wine Staging git commit
#   (HEAD of current git branch). If the __git_commit_reference variable is specified,
#   then use this to return the determined git commit. Otherwise output the git commit to stdout.
#
function wine_staging_get_upstream_commit()
{
	(((2 <= $#) && ($# <= 3))) || die "Invalid parameter count: ${#} (2-3)"

	local	__git_directory="${SOURCE_ROOT}/${1}" __wine_staging_git_commit="${2}" __git_commit_reference="${3}" \
			__git_commit

	pushd_wrapper "${__git_directory}"
	[[ "${__wine_staging_git_commit}" =~ ${SHA1_REGEXP} ]] \
		|| die "invalid Wine-Staging SHA-1 hash commit: \"${__wine_staging_git_commit}\""
	__git_commit=$( "${WINE_STAGING_PATCHINSTALL_SCRIPT}" --upstream-commit )
	[[ "${__git_commit}" =~ ${SHA1_REGEXP} ]] \
		|| die "unable to get Wine commit corresponding to Wine-Staging commit: \"${__wine_staging_git_commit}\""
	printf "%sChecking out Wine commit: %s${__git_commit}%s ; corresponding to Wine-Staging commit: %s${__wine_staging_git_commit}%s\\n" \
				"${TTYGREEN_BOLD}" "${TTYBLUE_BOLD}" "${TTYGREEN_BOLD}" "${TTYBLUE_BOLD}" "${TTYRESET}"
	popd_wrapper

	if [[ -z "${__git_commit_reference}" ]]; then
		echo "${__git_commit}"
	elif [[ "${__git_commit_reference}" =~ ${VARIABLE_NAME_REGEXP} ]]; then
		declare -n git_commit="${__git_commit_reference}"
		# shellcheck disable=SC2034
		git_commit="${__git_commit}"
	else
		die "Parameter (3): invalid reference name (${VARIABLE_NAME_REGEXP}): '${__git_commit_reference}'"
	fi
}

# function prune_commited_patches_from_array()
#
# Parameters:
#     1>  __git_directory         : git directory, under sources root  (string)
#     2>  __patch_array_reference : list of patches to check           (string array, reference)
#
# Description:
#   This functions accepts a single array of patch files. These files should have
#   one or more SHA-1 git commits in the patch header. These commit hashes correspond
#   to the original commit of the patch (one commit hash per each branch the patch was commited to),
#   in the specified git tree.
#   Referencing HEAD in the specified git tree, each patch is tested to see if it has been commited
#   at this reference point (i.e. is an ancestor commit). If the patch has been commited, then it
#   is deleted from the array.
#
prune_commited_patches_from_array()
{
	(($# == 2))	|| die "invalid parameter count: ${#} (2)"

	local __git_directory="${1%/}" __patch_array_reference="${2}" \
			__commit_hash __i_array __line

	if [[ ! -d "${__git_directory}/.git" ]]; then
		die "argument (1): path \"${__git_directory}\" is not a valid Git repository directory"
	fi
	if [[ ! "${__patch_array_reference}" =~ ${VARIABLE_NAME_REGEXP} ]]; then
		die "argument (2): invalid reference name (${VARIABLE_NAME_REGEXP}): '${__patch_array_reference}'"
	else
		declare -n patch_array="${__patch_array_reference}"
	fi

	pushd_wrapper "${__git_directory}"
	for __i_array in "${!patch_array[@]}"; do
		[[ -f "${patch_array[__i_array]}" ]] || die "patch file: \"${patch_array[__i_array]}\" does not exist"

		__line=0
		while
			: $((++__line))
			__commit_hash="$( sed -n -e "${__line}"'s/^.*\([[:xdigit:]]\{40\}\).*$/\1/p' "${patch_array[__i_array]}" )"
			[[ "${__commit_hash}" =~ ${SHA1_REGEXP} ]]
		do
			git merge-base --is-ancestor "${__commit_hash}" HEAD || continue

			printf "%sExcluding patch: %s%s\"%s${patch_array[__i_array]}%s%s\"%s ; parent Wine Git commit: %s${__commit_hash}%s\\n" \
			"${TTYGREEN_BOLD}" "${TTYRESET}" "${TTYGREEN}" "${TTYCYAN_BOLD}" "${TTYRESET}" "${TTYGREEN}" "${TTYGREEN_BOLD}" "${TTYBLUE_BOLD}" "${TTYRESET}"
			unset 'patch_array[__i_array]'
			break
		done
	done
	popd_wrapper
}

# function prune_commited_patches_from_arrays()
#
# Parameters:
#     1    >  __git_directory                                       : git directory, under sources root  (string)
#     2[-N]>  __patch_array_reference [... __patch_array_reference] : list of patches to check           (string array, reference)
#
# Description:
#   This functions accepts multiple arrays of patch files (__patch_array_reference ...). These files should have
#   one or more SHA-1 git commits in the patch header. These commit hashes correspond to the original commit
#   of the patch (one commit hash per each branch the patch was commited to), in the specified git tree.
#   These patch files are then individually processed by the function: prune_commited_patches_from_array()
#
prune_commited_patches_from_arrays()
{
	(($# >= 2))	|| die "invalid parameter count: ${#} (2-)"

	local __git_directory="${1%/}" __patch_array_reference

	shift 1
	for __patch_array_reference; do
		prune_commited_patches_from_array "${__git_directory}" "${__patch_array_reference}"
	done
}

# function process_staging_exclude()
#
# Parameters:
#     1>  __staging_exclude           : list of staging patchsets to check   (string)
#   [ 2<  __staging_exclude_reference : list of staging processed patchsets  (string, reference) ]
#
# Description:
#   This function should be called with the PWD setting to a wine-staging repository.
#   The function accepts a list of staging patchsets (__staging_exclude). Each patchset
#   is processed against the Wine Staging patchinstall.sh script to see the patchset is active
#   (at the current Wine Staging commit/version). If the patchset is not active then it is
#   removed from the list. This is a necessary step for earlier versions of Wine Staging,
#   which did not have for disabling invalid patchsets. The function ensures each
#   staging patchset reference is prefixed with the command switch '-W'.
#   The processed list of staging patchsets is returned either via the reference variable:
#   __staging_exclude_reference or via stdout.
#
function process_staging_exclude()
{
	(((1 <= $#) && ($# <= 2))) || die "Invalid parameter count: ${#} (1-2)"

	local	__staging_exclude="${1}" __staging_exclude_reference="${2}" \
			 __processed_staging_exclude

	__processed_staging_exclude=$( printf "%s" "${__staging_exclude}" \
		| gawk -vstaging_patch_file="${WINE_STAGING_PATCHINSTALL_SCRIPT}" \
		'
			function check_patchset_support(patchset,
				found)
			{
				gsub("(\\.|\\-|\\_)", "\\\\&", patchset)
				while ((getline line < staging_patch_file) > 0)
				{
					if (line ~ (patchset "\\)"))
					{
						found=1
						break
					}
				}
				close (staging_patch_file)
				return (found)
			}

			{
				for (i=1;i<=NF;++i)
				{
					i += ($i=="-W") ? 1 : 0
					if (check_patchset_support($i))
						printf("-W %s ", $i)
				}
			}
			END{
				printf("\n")
			}' 2>/dev/null
	)

	if [[ -z "${__staging_exclude_reference}" ]]; then
		echo "${__processed_staging_exclude}"
	elif [[ "${__staging_exclude_reference}" =~ ${VARIABLE_NAME_REGEXP} ]]; then
		declare -n __staging_exclude="${__staging_exclude_reference}"
		# shellcheck disable=SC2034
		__staging_exclude="${__processed_staging_exclude}"
	else
		die "Parameter (2): invalid reference name (${VARIABLE_NAME_REGEXP}): '${__staging_exclude_reference}'"
	fi
}

# function apply_binpatch_array()
#
# Parameters:
#     1    >  __source_directory  : source directory, to apply patches to   (string)
#     2[-N]>  __array_patch_files : 1(+) binary patches to apply            (string, array)
#
# Description:
#   The array of binary patches, __array_patch_files, is applied to the __source_directory.
#   These patches are applied using the Wine Staging patchbin script.
#
function apply_binpatch_array()
{
	((2 <= $#)) || die "Invalid parameter count: ${#} (2-)"

	local		__source_directory="${SOURCE_ROOT}/${1}"
	local -a	__array_patch_files=("${!2}")
	local -a	__array_sorted_patch_files
	local		__IFS_save __count=0 __binary_patch_file

	__IFS_save="${IFS}"
	# shellcheck disable=SC2207
	IFS=$'\n' __array_sorted_patch_files=($(sort <<<"${__array_patch_files[*]}"))
	IFS="${__IFS_save}"
	pushd_wrapper "${__source_directory}"
	for __binary_patch_file in "${__array_sorted_patch_files[@]}"; do
		[[ -z "${__binary_patch_file}" ]] && continue
		[[ -f "${__binary_patch_file}" ]] || die "binary patch file \"${__binary_patch_file}\" does not exist"

		printf "%s(%03d) Applying binary patch file%s: \"%s${__binary_patch_file}%s\" ...\\n" \
			"${TTYCYAN}" "$((__count+=1))" "${TTYGREEN_BOLD}" "${TTYCYAN_BOLD}" "${TTYRESET}"
		"${SOURCE_ROOT}/${WINE_STAGING_PATCHBIN_SCRIPT}" --nogit < "${__binary_patch_file}" \
			|| die "binary patch file: \"${__binary_patch_file}\" failed to apply"
	done
	popd_wrapper
}

# function apply_patch_array()
#
# Parameters:
#     1    >  __source_directory  : source directory, to apply patches to   (string)
#     2[-N]>  __array_patch_files : 1(+) patches to apply                   (string, array)
#
# Description:
#   The array of patches, __array_patch_files, is first sorted into standard order.
#   This therefore allows the function to apply numerically sorted patches in order.
#   The patches are then applied, to the __source_directory, using the patch utility.
#   Patches must be in a p1 format.
#
function apply_patch_array()
{
	((2 <= $#)) || die "Invalid parameter count: ${#} (2-)"

	local		__source_directory="${SOURCE_ROOT}/${1}"
	local -a	__array_patch_files=("${!2}")
	local -a	__array_sorted_patch_files
	local		__IFS_save __count=0 __patch_file __patch_log

	printf "%sUsing Source Directory%s: \"%s${__source_directory}%s\" ...\\n" \
		"${TTYCYAN}" "${TTYGREEN_BOLD}" "${TTYCYAN_BOLD}" "${TTYRESET}"
	__IFS_save="${IFS}"
	# shellcheck disable=SC2207
	IFS=$'\n' __array_sorted_patch_files=($(sort <<<"${__array_patch_files[*]}"))
	IFS="${__IFS_save}"
	pushd_wrapper "${__source_directory}"
	# shellcheck disable=SC2068
	for __patch_file in ${__array_sorted_patch_files[@]}; do
		[[ -z "${__patch_file}" ]] && continue
		[[ -f "${__patch_file}" ]] || die "patch file \"${__patch_file}\" does not exist"

		printf "%s(%03d) Applying patch file%s: \"%s${__patch_file}%s\" ...\\n" \
			"${TTYCYAN}" "$((__count+=1))" "${TTYGREEN_BOLD}" "${TTYCYAN_BOLD}" "${TTYRESET}"
		__patch_log="$(patch --verbose -p1 < "${__patch_file}" || false)"
		# shellcheck disable=SC2181
		if (($?)); then
			printf "%s\\n" "${TTYYELLOW}${__patch_log}${TTYRESET}"
			die "patch file: \"${__patch_file}\" failed to apply\\n" $?
		fi
	done
	popd_wrapper
}

# function apply_patch_directory()
#
# Parameters:
#     1>  source_directory  : source directory, to apply patches to   (string)
#     2>  patch_directory   : directory, containing patch files       (string)
#
# Description:
#   If the directory containing patches does not exist, then return with an
#   error. Otherwise collect all the files in this directory into an array.
#   Use this array as parameter to the function: apply_patch_array(). This
#   function actually applys these patches to the specified (source_directory)
#   directory.
#
function apply_patch_directory()
{
	((2 == $#)) || die "Invalid parameter count: ${#} (2)"

	local	source_directory="${1}" patch_directory="${2}" \
			__patch_file

	if [[ ! -d "${patch_directory}" ]]; then
		printf "%sIgnoring non-existent patch directory%s: \"%s${patch_directory}%s\"\\n" \
				"${TTYRED_BOLD}" "${TTYGREEN_BOLD}" "${TTYCYAN_BOLD}" "${TTYRESET}"
		return 1
	else
		printf "%sApplying patches from patch directory%s: \"%s${patch_directory}%s\" ...\\n" \
				"${TTYCYAN}" "${TTYGREEN_BOLD}" "${TTYBLUE}" "${TTYRESET}"
		local array_patch_files=()
		while IFS=  read -r -d $'\0' __patch_file; do
			array_patch_files+=("${__patch_file}")
		done < <(find "${patch_directory}" -type f -name "*.patch" -print0)

		apply_patch_array "${source_directory}" array_patch_files[@]
	fi
}

# function apply_user_patches()
#
# Parameters:
#     1>  source_directory  : source directory, to apply patches to   (string)
#
# Description:
#   Apply user patches to the specified (source_directory) directory.
#   Patches are stored in the directories, specified by the global
#   USER_PATCH_DIRECTORIES array (with numerical indices).
#   Any unset array indices are ignored.
#   The function: apply_patch_directory() ; is called to actually apply the patches.
#
function apply_user_patches()
{
	((1 == $#)) || die "Invalid parameter count: ${#} (1)"

	local	source_directory="${1}" \
			patch_directories_count="${#USER_PATCH_DIRECTORIES[@]}" \
			i patch_directory

	local i
	for ((i=0;i<patch_directories_count;++i)); do
		[[ "${USER_PATCH_DIRECTORIES[i]+valid}" ]] || continue

		patch_directory="${USER_PATCH_DIRECTORIES[i]}"
		apply_patch_directory "${source_directory}" "${patch_directory}"
	done
}

# function wine_fix_O3_compilation_support()
#
# Parameters:
#     1>  source_directory  : source directory, to which to apply fix  (string)
#
# Description:
#   This function fixes Wine compilation, when using -O3 in CFLAGS.
#   Uses sed, in a place of a patch, to avoid having to use multiple patch versions.
#   See: https://bugs.gentoo.org/480508
#
function wine_fix_O3_compilation_support()
{
	((1 == $#)) || die "Invalid parameter count: ${#} (1)"

	local	source_directory="${1%/}"

	if [[ ! -d "${source_directory}" ]]; then
		printf "%sInvalid source directory%s: \"%s${source_directory}%s\"\\n" \
				"${TTYRED_BOLD}" "${TTYGREEN_BOLD}" "${TTYCYAN_BOLD}" "${TTYRESET}"
		return 1
	fi

	# shellcheck disable=SC1004
	sed -i '/^ dnl Check for some compiler flags/a \
				WINE_TRY_CFLAGS([-fno-tree-loop-distribute-patterns])' \
			"${source_directory}/configure.ac" || die "sed failed"
}

# function wine_fix_winegcc_support()
#
# Parameters:
#     1>  source_directory  : source directory, to which to apply fix  (string)
#
# Description:
#   This function fixes winegcc multilib support.
#   Uses sed, in a place of a patch, to avoid having to use multiple patch versions.
#   See: https://bugs.gentoo.org/260726
#
function wine_fix_winegcc_support() {
	((1 == $#)) || die "Invalid parameter count: ${#} (1)"

	local -ar source_files=( "tools/winebuild/main.c" "tools/winegcc/winegcc.c" )
	local	source_directory="${1%/}"

	if [[ ! -d "${source_directory}" ]]; then
		printf "%sInvalid source directory%s: \"%s${source_directory}%s\"\\n" \
				"${TTYRED_BOLD}" "${TTYGREEN_BOLD}" "${TTYCYAN_BOLD}" "${TTYRESET}"
		return 1
	fi

	# shellcheck disable=SC2068
	for source_file in ${source_files[@]}; do
			sed -i \
			-e '/^#ifdef __i386__$/ i #undef FORCE_POINTER_SIZE' \
			-e '/^#elif defined(__x86_64__)$/ i #define FORCE_POINTER_SIZE' \
			-e '/^#elif defined(__powerpc__)$/ i #define FORCE_POINTER_SIZE' \
			"${source_directory}/${source_file}" || die "sed failed"
	done

	# shellcheck disable=SC1004
	sed -i -e '/^    signal[(] SIGINT, exit_on_signal [)];$/a\
\
#ifdef FORCE_POINTER_SIZE\
    force_pointer_size = sizeof(size_t);\
#endif' \
                "${source_directory}/${source_files[0]}" || die "sed failed"

	# shellcheck disable=SC1004
	sed -i -e '/^    signal[(] SIGINT, exit_on_signal [)];$/a\
\
#ifdef FORCE_POINTER_SIZE\
    opts.force_pointer_size = sizeof(size_t);\
#endif' \
                "${source_directory}/${source_files[1]}" || die "sed failed"
}

# function wine_fix_block_scope_compound_literals
#
# Parameters:
#     1>  source_directory  : source directory, to which to apply fix  (string)
#
# Description:
#   This function fixes issues with the lifetime of block scope compound literal's
#   definitions, in Wine. This fix is applied to Wine versions <=4.10. Technically this
#   issue only affects >=sys-devel/gcc-9.1.0, which checks for invalid literal scoping.
#   This global fix is applied unequivocally, irrespective of the compiler version
#   being used. Wine versions <=4.10, use invalid block scoping for a large number
#   of compound literals (potentially leading to issues, with more aggressive compiler
#   optimisations).
#
#   See: https://www.gnu.org/software/gcc/gcc-9/porting_to.html#complit
#   See: https://bugzilla.suse.com/show_bug.cgi?id=1137071
#
wine_fix_block_scope_compound_literals() {
	((1 == $#)) || die "Invalid parameter count: ${#} (1)"

	local	source_directory="${1%/}"

	if [[ ! -d "${source_directory}" ]]; then
		printf "%sInvalid source directory%s: \"%s${source_directory}%s\"\\n" \
				"${TTYRED_BOLD}" "${TTYGREEN_BOLD}" "${TTYCYAN_BOLD}" "${TTYRESET}"
		return 1
	fi

	printf "%sFixing compound literals (violating block scoping) ...%s\\n" \
					"${TTYCYAN}" "${TTYRESET}"
local -r awk_fix_block_scope_literals="${_WINE_AWK_FUNCTION_PROCESS_LITERAL_LINE} \
${_WINE_AWK_FUNCTION_IS_BROKEN_LITERAL} \
${_WINE_AWK_FUNCTION_PROCESS_SOURCE_FILE} \
${_WINE_AWK_FUNCTION_UPDATE_SOURCE_FILE} \
${_WINE_AWK_FIX_BLOCK_SCOPE_LITERALS}"

	find "${source_directory}" -type f \( -name "*.h" -o -name "*.idl" \) -print0 \
	| sort -z \
	| xargs -0 awk "${awk_fix_block_scope_literals}" \
		|| die "awk failed"
}

# function wine_winecfg_about_enhancement
#
# Parameters:
#     1>  source_directory  : source directory, to which to apply fix  (string)
#
# Description:
#   Improve formatting of Wine version, displayed on about tab, of the builtin winecfg utility.
#
wine_winecfg_about_enhancement() {
	((1 == $#)) || die "Invalid parameter count: ${#} (1)"

	local	source_directory="${1%/}"

	if [[ ! -d "${source_directory}" ]]; then
		printf "%sInvalid source directory%s: \"%s${source_directory}%s\"\\n" \
				"${TTYRED_BOLD}" "${TTYGREEN_BOLD}" "${TTYCYAN_BOLD}" "${TTYRESET}"
		return 1
	fi

	sed -i -e '/#include "config.h"/d' \
		-e '/#include <windows.h>/ i #include "config.h"' \
		-e '/[ ]-MulDiv([[:digit:]][[:digit:]], GetDeviceCaps(hDC, LOGPIXELSY), 72),$/{s/24,/16,/}' \
		-e '/^[ ]*SetWindowTextA(hWnd, [_[:upper:]]*);$/{s/PACKAGE_NAME/PACKAGE_STRING/}' \
		-e '/^[ ]*SetDlgItemTextA(hDlg, IDC_ABT_PANEL_TEXT, PACKAGE_VERSION);$/d' \
		-e '/IDC_ABT_PANEL_TEXT/d' \
		-e '/wine_get_version/d' \
		-e '/SendDlgItemMessageW(hDlg, IDC_ABT_TITLE_TEXT, WM_SETFONT, (WPARAM)titleFont, TRUE);$/ a SetDlgItemTextA(hDlg, IDC_ABT_TITLE_TEXT, PACKAGE_STRING);' \
		"${source_directory}/programs/winecfg/about.c" || die "sed failed"

	sed -i -e '/IDC_ABT_PANEL_TEXT/d' \
		"${source_directory}/programs/winecfg/resource.h" || die "sed failed"
	sed -i -e '/#include "config.h"/d' \
		-e '/#include "resource.h"/ i #include "config.h"' \
		-e '/^[ ]*LTEXT[ ]*/{s/".*",IDC_ABT_TITLE_TEXT,105,30,55,30/"",IDC_ABT_TITLE_TEXT,100,30,200,20/}' \
		-e '/^[ ]*LTEXT[ ]*"",IDC_ABT_PANEL_TEXT,160,43,140,8$/d' \
		-e '/IDC_ABT_WEB_LINK,"SysLink", LWS_TRANSPARENT, /{s/105,53,106,8$/100,53,106,8/}' \
		-e '/^[ ]*IDC_ABT_LICENSE_TEXT,/{s/105,64,145,66$/100,64,145,66/}' \
		"${source_directory}/programs/winecfg/winecfg.rc" || die "sed failed"
}

# function get_wine_addon_version()
#
# Parameters:
#     1>  __wine_git_directory           : Wine git directory     (string)
#     2>  __wine_addon                   : Wine 'gecko' / 'mono'  (string)
#   [ 3>  __wine_addon_version_reference : Wine addon version     (string, reference) ]
#
# Description:
#   This function references the specified Wine git directory (__wine_git_directory).
#   Note: this is specified relative to the global SOURCE_ROOT sources directory.
#   The function parses the Wine file: 'dlls/appwiz.cpl/addons.c' ; to determine
#   the version of the specified Wine addon (__wine_addon): 'gecko' / 'mono'.
#   If the __wine_addon_version_reference reference variable is specified then them
#   addon version is returned via this, otherwise it is output to stdout.
#
function get_wine_addon_version()
{
	(($# == 3)) || die "Invalid parameter count: ${#} (3)"

	local -r addon_file_relpath="dlls/appwiz.cpl/addons.c"
	local __wine_git_directory="${SOURCE_ROOT}/${1}" __wine_addon="${2}" \
				__wine_addon_version_reference="${3}" \
				__wine_addon_version

	__wine_addon_version="$(
		gawk -vwine_addon="${__wine_addon}" \
			'BEGIN{
				wine_addon=toupper(wine_addon)
			}
			{
				if ($0 ~ ("^#define " wine_addon "_VERSION")) {
					gsub("\"","", $NF)
					print $NF
					exit 0
				}
			}' \
			"${__wine_git_directory}/${addon_file_relpath}" 2>/dev/null
	)"

	# shellcheck disable=SC2154
	if [[ -z "${__wine_addon_version_reference}" ]]; then
		echo "${__wine_addon_version}"
	elif [[ "${__wine_addon_version_reference}" =~ ${VARIABLE_NAME_REGEXP} ]]; then
		declare -n wine_addon_version="${__wine_addon_version_reference}"
		# shellcheck disable=SC2034
		wine_addon_version="${__wine_addon_version}"
	else
		die "Parameter (3): invalid reference name (${VARIABLE_NAME_REGEXP}): '${__wine_addon_version_reference}'"
	fi
}

# function install_wine_addon()
#
# Parameters:
#     1>  wine_addon                   : Wine 'gecko' / 'mono'  (string)
#
# Description:
#	The function reads the stored wine addon msi installer(s) list from the
#   file:
#    * addons/{gecko,mono}.list (relative to SCRIPT_CACHE_DIRECTORY)
#   The msi installer file(s) are then transferred to:
#    * ~/.local/share/wine   (global: for current user)
#    * share/wine            (local:  relative to install PREFIX)
#   from:
#    * addons/{gecko,mono}/  (relative to SCRIPT_CACHE_DIRECTORY)
#
function install_wine_addon()
{
	(($# == 1)) || die "Invalid parameter count: ${#} (1)"

	local wine_addon="${1}" addon_file install_type target_directory
	local -r wine_addon_file_list="${SCRIPT_CACHE_DIRECTORY%/}/addons/${wine_addon}.list" \
			source_directory="${SCRIPT_CACHE_DIRECTORY%/}/addons/${wine_addon}"

	if ((WINE_ADDON_GLOBAL)); then
		target_directory="${HOME%/}${WINE_ADDON_GLOBAL_RELPATH%/}/${wine_addon}"
		install_type="globally"
	else
		target_directory="${PREFIX%/}/${WINE_ADDON_RELPATH#/}/${wine_addon}"
		install_type="locally"
	fi

	while read -r addon_file; do
		printf "%sInstalling %s%s%s file: \"%s%s%s\" ; %s%s to: %s%s%s ...%s\\n" \
					"${TTYCYAN}" "${TTYRED}" "wine-${wine_addon}" "${TTYCYAN}" \
					"${TTYBLUE_BOLD}" "${addon_file}" "${TTYCYAN}" \
					"${install_type}" "${TTYCYAN}" \
					"${TTYBLUE_BOLD}" "${target_directory}" "${TTYCYAN}" "${TTYRESET}"
		rsync -achv	"${source_directory}/${addon_file}" "${target_directory}/" \
			|| die "Installing wine-${wine_addon} file: \"${addon_file}\" ; ${install_type} (rsync) failed"
	done < "${wine_addon_file_list}"
}

#### Network Helper Functions Definition Block ####

# function get_optimum_repository_mirror()
#
# Parameters:
#   [ 1<  __repository_mirror_reference  : fastest local repository mirror URI   (string, reference) ]
#
# Description:
#	The function uses the Debian netselect-apt utility, or the Ubuntu mirror.txt facility,
#   to get a list of the top local mirrors. The Release hashes list - for the
#   Debian/Ubuntu release to be built - is downloaded from each of these mirrors. Since this
#   will need to be downloaded anyway - we can also eliminate any broken mirrors.
#   The download of the Release file is timed. The fastest mirror, of the top mirror list,
#   is selected using this time metric.
#   The best repository mirror URI is cached, for 24 hours, to speed up subsequent calls to this
#   function.
#   If the reference argument: __repository_mirror_reference ; is set then return the
#   repository mirror URI via this, otherwise output it to stdout.
#
get_optimum_repository_mirror()
{
	(($# <= 1)) || die "Invalid parameter count: ${#} (0-1)"

	local -r	__ubuntu_mirror_list="mirrors.ubuntu.com/mirrors.txt" \
				__repository_mirror_file="${LSB_DISTRIBUTION_ID}_mirror"
	local	__repository_mirror_reference="${1}" \
			__best_repository_mirror __best_repository_mirror_uri \
			__download_time __i=0 __i_best=0 __minimum_download_time \
			__modification_time __now_time \
			__repository_mirror_list __repository_mirror \
			__test_file_relpath
	local -a	__repository_mirror_array

	if [[ "${LSB_DISTRIBUTION_ID}" == "debian" ]]; then
		__test_file_relpath="dists/${LSB_CODENAME}/Release"
		__repository_mirror_list="$(
			netselect-apt "${LSB_CODENAME}" 2>/dev/null \
				| gawk '{ if ($1~"^(https{0,1}|ftp):") { print $1 } }'
		)"
	else
		__test_file_relpath="ubuntu/dists/${LSB_CODENAME}/Release"
		__repository_mirror_list="$(wget -qO - "${__ubuntu_mirror_list}")"
	fi
	# shellcheck disable=SC2206
	__repository_mirror_array=( ${__repository_mirror_list} )
	__temp_file="$(mktemp)"
	# try to use a cached mirror - if it's not too out-of-date (>1 day)...
	if [[ -f "${SCRIPT_CACHE_DIRECTORY%/}/${__repository_mirror_file}" ]]; then
		__modification_time="$(stat -c%Y "${SCRIPT_CACHE_DIRECTORY%/}/${__repository_mirror_file}")"
		__now_time="$(date -d now +%s)"
		if ((__now_time - __modification_time < 3600*24)); then
			__best_repository_mirror="$(cat "${SCRIPT_CACHE_DIRECTORY%/}/${__repository_mirror_file}")"
			__best_repository_mirror_uri="${__best_repository_mirror#*//}"
			__best_repository_mirror_uri="${__best_repository_mirror_uri%/${LSB_DISTRIBUTION_ID}/}"
			ping -qq -w5 -c1 "${__best_repository_mirror_uri}" >/dev/null \
				|| unset -v __best_repository_mirror
		fi
	fi
	if [[ -z "${__best_repository_mirror}" ]]; then
		for __repository_mirror in "${__repository_mirror_array[@]}"; do
			: $((++__i))
			rm -f "${__temp_file}" &>/dev/null
			if __download_time="$(
				env time -f '%e' wget -t 1 -T 4 -qO "${__temp_file}" "${__repository_mirror}/${__test_file_relpath}" 2>&1 \
					| gawk '{ if ($0 ~ "^[.[:digit:]]+$") { printf("%.0f\n", ($0*1000)) } else { exit 1 } }'
			)"; then
				printf "[%02d] %s mirror: %s (%d ms)\\n" \
						"$((__i))" "${LSB_DISTRIBUTION_ID^}" "${__repository_mirror}" "$((__download_time))"
			else
				printf "[%02d] %s mirror: %s (timeout)\\n" \
						"$((__i))" "${LSB_DISTRIBUTION_ID^}" "${__repository_mirror}"
				continue
			fi

			if ((!__i_best || (__download_time < __minimum_download_time))); then
				__i_best="$((__i))"
				__best_repository_mirror="${__repository_mirror}"
				__minimum_download_time="$((__download_time))"
			fi
		done
		echo "${__best_repository_mirror}" >"${SCRIPT_CACHE_DIRECTORY%/}/${__repository_mirror_file}"
		printf "\\n[%02d] Using best %s mirror: %s (%d ms)\\n" \
			"$((__i_best))" "${LSB_DISTRIBUTION_ID^}" "${__best_repository_mirror}" "$((__minimum_download_time))"
	else
		printf "\\nUsing best %s mirror: %s (cached)\\n" \
			"${LSB_DISTRIBUTION_ID^}" "${__best_repository_mirror}"
	fi



	if [[ -z "${__repository_mirror_reference}" ]]; then
		echo "${__best_repository_mirror}"
	elif [[ "${__repository_mirror_reference}" =~ ${VARIABLE_NAME_REGEXP} ]]; then
		declare -n repository_mirror="${__repository_mirror_reference}"
		# shellcheck disable=SC2034
		repository_mirror="${__best_repository_mirror}"
	else
		die "Parameter (1): invalid reference name (${VARIABLE_NAME_REGEXP}): '${__repository_mirror_reference}'"
	fi
}

# function fetch_wine_addon()
#
# Parameters:
#     1>  wine_addon          : Wine 'gecko' / 'mono'  (string)
#     2>  wine_addon_version  : Wine addon version     (string)
#
# Description:
#   This function actually downloads the specified, wine-gecko / wine-mono,
#   binary package (MSI installer), using wget. The required package(s)
#   (32-bit and/or 64-bit) are downloaded to the directory:
#    * addons/{gecko,mono}/ (relative to SCRIPT_CACHE_DIRECTORY)
#   The full package names are stored in the text file:
#    * addons/{gecko,mono}.list (relative to SCRIPT_CACHE_DIRECTORY)
#   This recorded packages names are used later, in the src_install phase,
#   to install the individual MSI package files.
#
function fetch_wine_addon()
{
	(($# == 2)) || die "Invalid parameter count: ${#} (2)"

	local	wine_addon="${1}" wine_addon_version="${2}" \
				arch arch_suffix no_arch_suffix=0 separator="-" \
				wine_addon_file wine_addon_uri wine_addon_version
	local -a arch_array

	case "${wine_addon}" in
		gecko)
			arch_array+=( "32" "64" )
			if [[ "${wine_addon_version}" =~ ^2.40|2.44|2.47$ ]]; then
					separator="_"
			fi
			;;
		mono)
			arch_array+=( "32" )
			if [[ "${wine_addon_version}" == 4.* ]]; then
					no_arch_suffix=1
			fi
			;;
		*)
			die "Parameter (1): invalid Wine addon specified: \"${wine_addon}\""
			;;
	esac
	local -r wine_addon_file_list="${SCRIPT_CACHE_DIRECTORY%/}/addons/${wine_addon}.list" \
				source_directory="${SCRIPT_CACHE_DIRECTORY%/}/addons/${wine_addon}"

	wine_addon_uri="${WINE_ADDON_URI%/}/wine-${wine_addon}/${wine_addon_version}"

	rm -f "${wine_addon_file_list}"  &>/dev/null
	for arch in "${arch_array[@]}"; do
		((arch == 32)) 		&& arch_suffix="x86"
		((arch == 64)) 		&& arch_suffix="x86_64"
		((no_arch_suffix))	&& arch_suffix=""
		wine_addon_file="wine${separator}${wine_addon}-${wine_addon_version}${arch_suffix:+-}${arch_suffix}.msi"
		echo "${wine_addon_file} " >> "${wine_addon_file_list}"

		printf "Fetching %s-bit %swine-%s%s MSI package from URI: \"%s%s%s\"\\n" \
				"${arch}" "${TTYGREEN}" "${wine_addon}" "${TTYRESET}"  \
				"${TTYBLUE}" "${wine_addon_uri}/${wine_addon_file}" "${TTYRESET}"
		mkdir -p "${SCRIPT_CACHE_DIRECTORY%/}/addons/${wine_addon}/" \
				|| die "mkdir \"${SCRIPT_CACHE_DIRECTORY%/}/addons/${wine_addon}/\" failed"
		wget -t 10 -c -O "${SCRIPT_CACHE_DIRECTORY%/}/addons/${wine_addon}/${wine_addon_file}" \
				"${wine_addon_uri}/${wine_addon_file}" \
				|| die "wget failed to fetch ${arch}-bit wine-${wine_addon} MSI package from URI: \"${wine_addon_uri}/${wine_addon_file}\""
	done
}

#### Schroot / Chroot Function Definition Block ####

# function schroot_session_start()
#
# Parameters:
#     1>  session  : schroot session name  (string)
#     2>  user     : schroot session user  (string)
#     3>  chroot   : schroot chroot name   (string)
#
# Description:
#   This function forceably ends any existing Schroot session
#   with the same name (session).
#   This function then starts a new session (session), for
#   the specified Linux user (user) and chroot (chroot). Where
#   the chroot name, directory maps to a subdirectory under:
#    * /srv/chroot/${chroot}
#
function schroot_session_start()
{
	(($# == 3)) || die "Invalid parameter count: ${#} (3)"

	local	session="${1#session:}" \
			user="${2}" \
			chroot="chroot:${3#chroot:}"

	schroot -e -c "session:${session}" &>/dev/null
	printf "%s" "${TTYPURPLE}"
	schroot -b -c "${chroot}" -u "${user}" -n "${session}"
	# shellcheck disable=SC2181
	(($?)) && die "schroot -b -c \"${chroot}\" -u \"${user}\" -n \"${session}\" (session start) failed"
	printf "%s" "${TTYRESET}"
}

# function schroot_session_run()
#
# Parameters:
#     1    >  session         : schroot session name                     (string)
#     2    >  user            : schroot session user                     (string)
#	  3    >  directory       : schroot start directory                  (string)
#	  4[-N]>  commands_array  : commands to run, in schroot environment  (string, array)
#
# Description:
#   This function then runs a, pre-existing, session (session), for
#   the specified Linux user (user), using the specified working directory (directory).
#   The command sequence (commands_array) is run one-by-one with any failure, to
#   execute an individual command, being reported as a fatal error.
#
function schroot_session_run()
{
	(($# >= 4)) || die "Invalid parameter count: ${#} (4-)"

	local -r	session="session:${1#session:}" \
				user="${2}" \
				directory="${3:-${PWD}}"
	local -a commands_array=( "${@:4}" )

	local i
	printf "%s" "${TTYCYAN}"
	for i in ${!commands_array[*]}; do
		schroot -r -c "${session}" -u "${user}" -d "${directory}" -- sh -c "${commands_array[i]}"
		# shellcheck disable=SC2181
		(($?)) && die "schroot -r -c \"${session}\" -u \"${user}\" -d \"${directory}\" -- ${commands_array[i]} (session run) failed"
	done
	printf "%s" "${TTYRESET}"
}

# function schroot_session_cleanup()
#
# Parameters:
#	  1[-N]>  sessions_array  : schroot sessions to end  (string, array)
#
# Description:
#   This function terminates all the Schroot sessions, specified in the
#   sessions_array. This action is performed as single command.
#
function schroot_session_cleanup()
{
	(($# >= 1)) || die "Invalid parameter count: ${#} (1-)"

	local -r sessions_array=( "${@}" )
	local sessions

	printf "%s" "${TTYPURPLE}"
	# shellcheck disable=SC2068
	for session in ${sessions_array[@]}; do
		sessions="${sessions} -c session:${session#session:}"
	done
	# shellcheck disable=SC2086
	schroot -e ${sessions}
	printf "%s" "${TTYRESET}"
}

# function schroot_image_bootstrap()
#
# Parameters:
#     1>  chroot_name   : schroot chroot name   (string)
#     2>  architecture  : schroot architecture  (string)
#
# Description:
#   This function sets up a single Schroot environment (chroot_name), using the specified
#   architecture schroot architecture (32-bit or 64-bit). This script, globally, uses dual
#   Schroots. One Schroot is a 32-bit architecture Schroot, the other is a 64-bit architecture
#   Schroot.
#   The step process is carried out in two steps:
#
#     1) Generate the global configuration file for the current Schroot. This configuration
#        file will include an architecture-specific section.
#        Files, specifying locale and keyboard settings, are added to the configuration - so
#        the Schroot will use the same settings as the Host System.
#
#     2) The Debian command debootstrap is called to setup a basic Linux FHS filesystem, and
#        pull-down a base set of packages, required to make a functional Debian chroot
#        environment.
#
#        The global configuration option, LSB_CODENAME, defaults to being the same as the
#        Host System. However, overriding LSB_CODENAME allows you build Wine for a different
#        release version of Debian / Ubuntu.
#
schroot_image_bootstrap()
{
	(($# == 2)) || die "Invalid parameter count: ${#} (2)"

	local -r	chroot_name="${1}" architecture="${2}"
	local -r	lsb_description="$(lsb_release -sd)" \
			chroot_path="/srv/chroot/${chroot_name}" \
			schroot_conf_subdirectory="chroot.d" \
			schroot_fstab_subdirectory="${chroot_name%_[36][24]bit}" \
			schroot_main_conf_directory="/etc/schroot" \
			dpkg_force_reinstall_conf="sudo apt-get install --reinstall -o Dpkg::Options::=\"--force-confask,confnew,confmiss\""
	local 	path schroot_directory schroot_file

	# Check for missing Schroot configuration directories and files (otherwise Schroot will nope out on us)...
	for schroot_directory in "${schroot_main_conf_directory}"/{chroot.d,default,setup.d}; do
		[[ -d "${schroot_directory}" ]]	&& continue

		printf "Please re-install the %sschroot%s package configuration files:\\n%s\\n%s\\n" \
				"${TTYCYAN_BOLD}" "${TTYRESET}" \
				"${TTYCYAN_BOLD}${dpkg_force_reinstall_conf} schroot${TTYRESET}" \
				"${TTYCYAN_BOLD}${dpkg_force_reinstall_conf} \"$(dpkg -S \"${schroot_directory}\" | sed 's/,//g; s/:.*//')\"${TTYRESET}"
		die "Schroot package misconfigured"
	done
	for schroot_file in "${schroot_main_conf_directory}"/{schroot.conf,/default/copyfiles}; do
		[[ -f "${schroot_file}" ]] 		&& continue

		printf "Please re-install the %sschroot%s package configuration files:\\n%s\\n" \
				"${TTYCYAN_BOLD}" "${TTYRESET}" \
				"${TTYCYAN_BOLD}${dpkg_force_reinstall_conf} schroot${TTYRESET}"
		die "Schroot package misconfigured"
	done

	mkdir -p "${schroot_main_conf_directory}/${schroot_fstab_subdirectory}" || die "mkdir failed"
	rsync -achv "${schroot_main_conf_directory}/default/fstab" "${schroot_main_conf_directory}/${schroot_fstab_subdirectory}/fstab" \
		|| die "Cloning file: \"${schroot_main_conf_directory}/default/fstab\" ; to: \"${schroot_main_conf_directory}/${schroot_fstab_subdirectory}/fstab\" (rsync) failed"

	case "${architecture}" in
		i386)	(
	cat <<EOF_Schroot_wine32
[${chroot_name}]
description=${lsb_description} (32-bit)
personality=linux32
EOF_Schroot_wine32
				) > "${schroot_main_conf_directory}/${schroot_conf_subdirectory}/${chroot_name}.conf"
			;;
		amd64)	(
	cat <<EOF_Schroot_wine64
[${chroot_name}]
description=${lsb_description} (64-bit)
EOF_Schroot_wine64
				) > "${schroot_main_conf_directory}/${schroot_conf_subdirectory}/${chroot_name}.conf"
			;;
		*)
			die "Invalid Schroot architecture specified: '${architecture}' (specify: 'i386' or 'amd64')"
			;;
	esac
	(
		cat <<EOF_Schroot_wine
setup.fstab=${schroot_fstab_subdirectory}/fstab
directory=${chroot_path}
message-verbosity=verbose
root-users=root
type=directory
users=${USERNAME}
preserve-environment=true
EOF_Schroot_wine
	) >> "${schroot_main_conf_directory}/${schroot_conf_subdirectory}/${chroot_name}.conf"

	for path in "/etc"/{locale.gen,timezone} "/etc/default"/{console-setup,keyboard,locale}; do
		# Append host locale & keyboard default configuration files to schroot copyfiles configuration file.
		# sed command only appends file names - if not already present.
		if [[ -f "${path}" ]]; then
			sed -i -e "\\|${path}|h; \${x;s|${path}||;{g;t};a\\" -e "${path}" -e "}" \
				"${schroot_main_conf_directory}/default/copyfiles" || die "sed failed"
		else
			sed -i "\\|${path}|d" \
				"${schroot_main_conf_directory}/default/copyfiles" || die "sed failed"
		fi
	done
	printf "%s" "${TTYPURPLE}"
	# shellcheck disable=SC2153
	debootstrap --variant=buildd --arch"=${architecture}" "${LSB_CODENAME}" \
			"${chroot_path}" "${REPOSITORY_MIRROR_URI}"

	if mountpoint "/home/${USERNAME}" &>/dev/null; then
		sed -i -n 'p; s|/home[ ][ ]\{'"${#USERNAME}"'\}|/home/'"${USERNAME}"'|gp' \
			"${schroot_main_conf_directory}/${schroot_fstab_subdirectory}/fstab"
		mountpoint "/home" &>/dev/null || mkdir -p "${chroot_path}/home/${USERNAME}"
	fi
	
	gawk -vfstab_file="${schroot_main_conf_directory}/${schroot_fstab_subdirectory}/fstab" \
		'function is_mounted(mountpoint, self_mounts_array,
				line) {
			gsub("[ ].*$","",mountpoint)
			for (line=1; line<=self_mounts_array[0]; ++line) {
				if (mountpoint == self_mounts_array[line]) return 1
			}
			return 0
		}

		BEGIN{
			while (getline fstab_line < fstab_file) {
				fstab_array[++fstab_array[0]]=fstab_line
			}
			close(fstab_file)
		}
		{
			if ($2 ~ "^/") self_mounts_array[++self_mounts_array[0]]=$2
		}
		END{
			for (line=1; line<=fstab_array[0]; ++line) {
				if ((fstab_array[line] !~ "^/") ||
					is_mounted(fstab_array[line], self_mounts_array))
					continue

				sub("^","#",fstab_array[line])
			}

			printf("%s\n", fstab_array[1]) >fstab_file
			for (line=2; line<=fstab_array[0]; ++line) {
				printf("%s\n", fstab_array[line]) >>fstab_file
			}
		}' "/proc/self/mounts"

	printf "%s" "${TTYRESET}"
}

# function setup_chroot_build_env()
#
# Parameters:
#     1>  chroot_name  : schroot chroot name   (string)
#
# Description:
#   This function initally ensures that the chroot environment has a valid
#   locale set - using either: the Host System locale or fall-back of 'en_US.UTF-8'.
#   We then setup a minimal repository list, using our previously determined
#   Debian / Ubuntu mirror URI (REPOSITORY_MIRROR_URI), within the chroot environment.
#   A base-minimal package is chosen, depending on the Linux Distribution
#   (Debian / Ubuntu).
#   We then start Schroot, as root. Next we run the Schroot, installing a base set
#   of packages and set the Schroot locale. Once these packages are succeeded
#   installed, we shutdown/end the Schroot.
#
#   NOTE: this function uses 'apt-get', rather than the newer 'apt' wrapper command,
#   as recommended by the 'apt' manpage.
#
setup_chroot_build_env()
{
	(($# == 1)) || die "Invalid parameter count: ${#} (1)"

	local -r	chroot_name="${1}" \
				session="${SESSION_WINE_INITIALISE}" \
				session_directory="/var/lib/schroot/session/" \
				session_mountpoint="/var/run/schroot/mount/"
	local		chroot_path="/srv/chroot/${chroot_name}" \
				locale_lang repository_categories schroot_directory


	if [[ ! -d "${chroot_path}" ]]; then
		die "Schroot chroot root directory: '${chroot_path}' ; does not exist"
	fi

	# Create any missing Schroot configuration directories (otherwise Schroot will nope out on us)...
	for schroot_directory in "${session_directory}" "${session_mountpoint}"; do
		[[ -d "${schroot_directory}" ]]	&& continue

		mkdir -p "${schroot_directory}" || die "mkdir -p '${schroot_directory}' failed"
	done

	locale_lang="$( locale | gawk -F'=' '$1=="LANG" { print $2 }' )"
	# Generate a dummy /etc/locale.gen file for Schroot

	if [[ ! -f "${chroot_path}/etc/locale.gen" ]]; then
		grep -s "${locale_lang}" "${chroot_path}/usr/share/i18n/SUPPORTED" \
			> "${chroot_path}/etc/locale.gen"
		printf "en_US.UTF-8 UTF-8\\n" >> "${chroot_path}/etc/locale.gen"
	else
		sed -i	-e "\\|${locale_lang}|{s|^\\#[[:blank:]]\\+||}" \
				-e "\\|en_US.UTF-8|{s|^\\#[[:blank:]]\\+||}" \
			"${chroot_path}/etc/locale.gen"
	fi
	schroot_session_start "${session}" "root" "${chroot_name}"

	case "${LSB_DISTRIBUTION_ID}" in
		debian)
			repository_categories="main contrib"
			;;
		ubuntu)
			repository_categories="main restricted multiverse universe"
			;;
		*)
			die "Unsupported Distribution ID: ${LSB_DISTRIBUTION_ID}"
			;;
	esac

	cat > "${chroot_path}/etc/apt/sources.list" <<EOF_SOURCES_LIST
deb ${REPOSITORY_MIRROR_URI} ${LSB_CODENAME} ${repository_categories}
deb-src ${REPOSITORY_MIRROR_URI} ${LSB_CODENAME} ${repository_categories}
EOF_SOURCES_LIST

	schroot_session_run "${session}" "root" "/" \
		"dpkg --configure -a --force-confnew,confmiss" \
		"apt-get -o Dpkg::Options::=\"--force-confnew\" install -y apt-utils locales" \
		"locale-gen ${locale_lang}" \
		"apt-get -o Dpkg::Options::=\"--force-confnew\" update -qq -y" \
		"apt-get -o Dpkg::Options::=\"--force-confnew\" upgrade -qq -y" \
		"rm -f \"/etc\"/{protocols,services,systemd/resolved.conf}" \
		"dpkg-reconfigure --frontend=noninteractive locales" \
		"update-locale LANG=${locale_lang}"
	schroot_session_cleanup "${session}"
}

# function upgrade_chroot_build_env()
#
# Parameters:
#     1>  chroot_name  : schroot chroot name   (string)
#
# Description:
#   This function initally updates the chroot environment. The function then
#   ensures we have a full complement of Wine development packages.
#
#   FIXME: integrating faudio support, is not currently supported.
#
#   NOTE: this function uses 'apt-get', rather than the newer 'apt' wrapper command,
#   as recommended by the 'apt' manpage.
#
upgrade_chroot_build_env()
{
	(($# == 1)) || die "Invalid parameter count: ${#} (1)"

	local -r	chroot_name="${1}"
	local	  	session="${SESSION_WINE_INITIALISE}"
	local -r	chroot_path="/srv/chroot/${chroot_name}"

	schroot_session_start "${session}" "root" "${chroot_name}"
	schroot_session_run "${session}" "root" "/" \
		"dpkg --configure -a --force-confnew,confmiss" \
		"rm -f \"/etc\"/{protocols,services}" \
		"apt-get -o Dpkg::Options::=\"--force-confnew\" update -qq -y" \
		"apt-get -o Dpkg::Options::=\"--force-confnew\" upgrade -qq -y" \
		"apt-get -o Dpkg::Options::=\"--force-confnew\" install -qq -y autoconf libva-dev libgtk-3-dev libudev-dev libgphoto2-dev libcapi20-dev libsane-dev libkrb5-dev libsdl2-dev libvulkan-dev" \
		"rm -f \"/etc\"/{protocols,services}" \
		"dpkg --configure -a --force-confnew,confmiss" \
		"rm -f \"/etc/protocols\"" \
		"apt-get -o Dpkg::Options::=\"--force-confnew\" build-dep -qq -y -f wine-development" \
		"rm -f \"/etc\"/{protocols,services}" \
		"apt-get -o Dpkg::Options::=\"--force-confnew\" upgrade -qq -y"
	schroot_session_cleanup "${session}"
}

#### Package Phases Function Definition Block ####

# function src_fetch() [PHASE (1)]
#
# Parameters: <none>
#
# Description:
#   The src_fetch() function initally cleans the build directories.
#   The function then pulls down a set of stock Gentoo
#   app-emulation/wine-{staging,vanilla} patches. The only function
#   of these patches is to fix build errors, with earlier versions of Wine.
#
#   If building Wine Staging then we clone (if necessary) and update a
#   local copy of the wine-staging Git repository. We then set the repository
#   tag. This will be one of (the globally set) Wine Staging:
#    * release version
#    * git commit hash
#    * git branch
#   If not building a Wine Staging release version, then we get the Upstream
#   Wine git commit, corresponding to the currently set Wine Staging git commit
#   (the Wine git commit will override the Wine git tag we use - see below).
#   Finally a backported eventfd_synchronization patchset fix is applied (if necessary).
#
#   Next the function clones (if necessary) and updates a
#   local copy of the wine Git repository. We then set the repository
#   tag. This will be one of (the globally set) Wine:
#    * release version
#    * git commit hash (NOTE: this maybe set in the previous Wine-Staging block)
#    * git branch
#
#   Finally we fetch the Wine addon (pre-built) binary packages (wine-gecko and wine-mono).
#   These packages are in the form of MSI installer files.
#
function src_fetch()
{
	(($# == 0)) || die "Invalid parameter count: ${#} (0)"

	local wine_gecko_version wine_mono_version

	printf "\\n\\n%s${FUNCNAME[ 0 ]} ()%s ... \\n" "${TTYWHITE_BOLD}" "${TTYRESET}"

	clean_build_directories "${BUILD_ROOT}/wine64" "${BUILD_ROOT}/wine32" "${BUILD_ROOT}/wine32_tools"
	pushd_wrapper "${SOURCE_ROOT}"
	fetch_and_extract_tarball . "${GENTOO_WINE_EBUILD_COMMON_PACKAGE_URI}" "${GENTOO_WINE_EBUILD_COMMON_PACKAGE}"

	# Fetch Wine-Staging Git Source (if required).
	# Checkout desired Wine version in Wine-Staging Git tree (clean and update first!!)
	if ((WINE_STAGING)); then
		git_clone "${WINE_STAGING_GIT_URI}"
		git_pull "wine-staging"
		git_set_tag "wine-staging" "${__WINE_STAGING_GIT_TAG}"
		git_get_commit "wine-staging" "__WINE_STAGING_COMMIT"
		if [[ -n "${WINE_STAGING_BRANCH}" || -n "${WINE_STAGING_COMMIT}" ]]; then
			wine_staging_get_upstream_commit "wine-staging" "${__WINE_STAGING_COMMIT}" "__WINE_GIT_TAG"
		fi
		# shellcheck disable=SC2068
		if git_is_commit_in_range "wine-staging" ${EVENTFD_BROKEN_DIR_CHANGE_NOTIFICATION_COMMIT_RANGE[@]}; then
			wget -c -O "${WORKING_PATCHES_DIRECTORY}/${WINE_STAGING_COMMIT_c48811407e3_PATCH}" \
								"${WINE_STAGING_COMMIT_c48811407e3_URI}" \
				|| die "wget failed: unable to download eventfd_synchronization fix patch: \"${WINE_STAGING_COMMIT_c48811407e3_URI}\""
		fi
	fi

	# Fetch Wine Git Source (if required). Checkout desired Wine version in Wine Git tree (clean and update first!!)
	git_clone "${WINE_GIT_URI}"
	git_pull "wine"
	git_set_tag "wine" "${__WINE_GIT_TAG}"

	# Fetch Wine addon binary packages (wine-gecko and wine-mono)
	get_wine_addon_version "wine" "gecko"  "wine_gecko_version"
	fetch_wine_addon "gecko" "${wine_gecko_version}"
	get_wine_addon_version "wine"  "mono"  "wine_mono_version"
	fetch_wine_addon "mono" "${wine_mono_version}"
	popd_wrapper
}

# function src_prepare() [PHASE (2)]
#
# Parameters: <none>
#
# Description:
#   The src_prepare() function initally hashes the current wineserver
#   protocol definition file. This hash will be used, later on in this
#   function, to test if we need to rebuild the server/trace.c and
#   server/request.h files. These files are generated, automatically,
#   using the current set of wineserver protocol definitions.
#
#   (1) Generate a list of the current set of Gentoo patches.
#       These patches are used to fix compilation issues, with earlier
#       versions of Wine. There is a custom patch, to improve
#       the appearance of the About tab in winecfg.
#       Additionally there is a binary patch, used to fix
#       font file issues, related to a previous freetype update.
#       The sets of patches (binary and text) is filtered to remove any
#       patches that have already been commited to the wine git tree
#       (based on the currently set wine git HEAD commit). Any patches,
#       remaining in the sets, are applied to wine git tree.
#       Two functions are called to fix Wine/winegcc compilation issues:
#        * wine_fix_O3_compilation_support()
#        * wine_fix_winegcc_support()
#
#   (2) Apply the Wine Staging patchset to the wine git tree.
#       Intially a test is made to see if an eventfd_synchronization fix
#       requires backporting, to the current wine-staging commit. This
#       issues only effects 6 wine-staging commits around the
#       Wine Staging 4.7 release.
#       Any Wine Staging patchsets, that are to be disabled, are read from
#       the global variable:
#         WINE_STAGING_EXCLUDE
#       Patchsets are disabled due to conflicts (e.g. if they are patched in
#       seperately), etc.
#       The patches are applied using the bundled Wine Staging: patchinstall.sh ;
#       script.
#       Finally Wine Staging branding is applied, to the Wine version string.
#
#   (3) Apply any specified user patches to the wine git tree.
#       These patches should be stored in the directories specified, in the
#       global USER_PATCH_DIRECTORIES[0][ -USER_PATCH_DIRECTORIES[N-1] ] array.
#       Patches, in each individual user patch directory, can be numerically
#       sequenced (0001*.patch 0002*.patch etc.). Patches will be applied in
#       the correct order in this instance.
#
#   The function then performs any necessary re-configuration, resulting from
#   the previous patching operations.
#
function src_prepare()
{
	(($# == 0)) || die "Invalid parameter count: ${#} (0)"

	printf "\\n\\n%s${FUNCNAME[ 0 ]} ()%s ... \\n" "${TTYWHITE_BOLD}" "${TTYRESET}"

	local	md5hash
	md5hash="$(md5sum "${SOURCE_ROOT}/wine/server/protocol.def" || die "md5sum failed")"

	# (1) Apply base (bundled) & working patches. Call 2 helper functions ...
	local -a	array_patch_files=(
		"${SOURCE_ROOT}/${WINE_EBUILD_COMMON}/patches/wine-1.8-gstreamer-1.0_"{01,02,03,04,05,06,07,08,09,10,11}".patch"
		"${SOURCE_ROOT}/${WINE_EBUILD_COMMON}/patches/wine-1.9.9-sysmacros.patch"
		"${SOURCE_ROOT}/${WINE_EBUILD_COMMON}/patches/wine-1.9.13-gnutls-3.5-compat.patch"
		"${SOURCE_ROOT}/${WINE_EBUILD_COMMON}/patches/wine-1.9.14-cups-2.2-cupsgetppd-build-fix.patch"
		"${SOURCE_ROOT}/${WINE_EBUILD_COMMON}/patches/wine-2.13-fix_build_with_newer_pcap.patch"
		"${SOURCE_ROOT}/${WINE_EBUILD_COMMON}/patches/wine-2.18-freetype-2.8.1-drop-glyphs.patch"
		"${SOURCE_ROOT}/${WINE_EBUILD_COMMON}/patches/wine-2.18-freetype-2.8.1-segfault.patch"
		"${SOURCE_ROOT}/${WINE_EBUILD_COMMON}/patches/wine-2.7-osmesa-configure_support_recent_versions.patch"
		"${SOURCE_ROOT}/${WINE_EBUILD_COMMON}/patches/wine-4.3-fix_build_with_newer_pcap.patch"
	)
	# shellcheck disable=SC2034
	local -a	array_binpatch_files=(
		"${SOURCE_ROOT}/${WINE_EBUILD_COMMON}/patches/wine-2.18-freetype-2.8.1-implement_minimum_em_size_required_by_opentype_1.8.2.patch"
	)

	wine_fix_O3_compilation_support "${SOURCE_ROOT}/wine"
	wine_fix_winegcc_support "${SOURCE_ROOT}/wine"

	mkdir -p "${WORKING_PATCHES_DIRECTORY}"
	prune_commited_patches_from_arrays "${SOURCE_ROOT}/wine" array_patch_files array_binpatch_files
	apply_patch_array "wine" array_patch_files[@]
	apply_binpatch_array "wine" array_binpatch_files[@]

	wine_winecfg_about_enhancement "${SOURCE_ROOT}/wine"
	wine_fix_block_scope_compound_literals "${SOURCE_ROOT}/wine"

	# (2) Apply Wine-Staging patchset ...
	if ((WINE_STAGING)) && [[ -d "${SOURCE_ROOT}/wine-staging" ]]; then
		(
			local	staging_exclude

			# if required, fix up eventfd_synchronization support for Wine Staging version 4.7 (and preceeding 6 commits)
			# shellcheck disable=SC2199,SC2068
			if git_is_commit_in_range "wine-staging" ${EVENTFD_BROKEN_DIR_CHANGE_NOTIFICATION_COMMIT_RANGE[@]}; then
				array_patch_files=( "${WORKING_PATCHES_DIRECTORY}/${WINE_STAGING_COMMIT_c48811407e3_PATCH}" )
				apply_patch_array "wine-staging" array_patch_files[@]
			fi

			pushd_wrapper "${SOURCE_ROOT}/wine-staging"
			# shellcheck disable=SC2030
			WINE_STAGING_EXCLUDE="${WINE_STAGING_EXCLUDE} configure-OSMesa winhlp32-Flex_Workaround"
			process_staging_exclude "${WINE_STAGING_EXCLUDE}" "staging_exclude"
			# Disable Upstream (Wine Staging) about tab customisation, for winecfg utility, to support our own version
			if [[ -f "patches/winecfg-Staging/0001-winecfg-Add-staging-tab-for-CSMT.patch" ]]; then
				sed -i '\|^diff \-\-git a/programs/winecfg/about.c|,+12d' \
					"patches/winecfg-Staging/0001-winecfg-Add-staging-tab-for-CSMT.patch" &>/dev/null
			fi
			printf "%sApplying Wine-Staging patchset %s...\\n%spatchinstall.sh %sDESTDIR=\"%s${SOURCE_ROOT}/wine%s\" --no-autoconf --all ${staging_exclude}%s\\n" \
					"${TTYCYAN}" "${TTYGREEN_BOLD}" "${TTYCYAN_BOLD}" "${TTYGREEN_BOLD}" "${TTYBLUE_BOLD}" "${TTYGREEN_BOLD}" "${TTYCYAN}"
			# shellcheck disable=SC2086
			"${WINE_STAGING_PATCHINSTALL_SCRIPT}" DESTDIR="${SOURCE_ROOT}/wine" --no-autoconf --all ${staging_exclude} \
				|| die "Wine-Staging \"${SOURCE_ROOT}/wine-staging/${WINE_STAGING_PATCHINSTALL_SCRIPT}\" failed" $?
			printf "%s" "${TTYRESET}"
			popd_wrapper
		)
		if [[ "${__WINE_STAGING_VERSION}" =~ ${VERSION_REGEXP} && "${__WINE_STAGING_VERSION}" =~ ${STABLE_VERSION_REGEXP} ]]; then
			# Handle "unofficial" stable Staging versions
			sed -i "s/(Staging)/(Staging${WINE_STAGING_SUFFIX})/" "${SOURCE_ROOT}/wine/libs/wine/Makefile.in" || die "sed failed" $?
		fi
		# Update Wine package name for Staging patchset
 		sed -r -i '/^AC_INIT\(.*\)$/{s/\[Wine\]/\[Wine \(Staging\)\]/}' "${SOURCE_ROOT}/wine/configure.ac" || die "sed failed" $?
		sed -r -i "s/Wine (\\(Staging\\) |)/Wine \\(Staging\\) /" "${SOURCE_ROOT}/wine/VERSION" || die "sed failed" $?
	fi

	# (3) Apply user patches ...
	apply_user_patches "wine"

	pushd_wrapper "${SOURCE_ROOT}/wine"
	# Run autoreconf to update configuration - post application of all patches
	schroot_session_run "${SESSION_WINE32}" "${USERNAME}" "" \
		"autoreconf"
	if ! md5sum -c - <<<"${md5hash}" &>/dev/null; then
		printf "\"%s${PWD}/protocol.def%s\"%s was patched; running \"%s${PWD}/tools/make_requests%s\" ... \\n" \
			"${TTYBLUE_BOLD}" "${TTYRESET}" "${TTYCYAN}" "${TTYCYAN_BOLD}" "${TTYRESET}"
		tools/make_requests || die "\"${PWD}/tools/make_requests\" failed"
	fi
 	popd_wrapper
}

# function multilib_src_configure() [PHASE (3)]
#
# Parameters: <none>
#
# Description:
#   The multilib_src_configure() function cleans, and
#   runs the Wine source configure script, in the following
#   Wine build directories:
#    1) wine64
#    2) wine32_tools
#   (in the specified order).
#
#   The third (and final) Wine build directory:
#    3) wine32
#   cannot be configured yet. It must wait until the other two
#   build directories have been compiled - see PHASE(4).
#
#   The global variable: WINE_CFLAGS ; is used to set the CFLAGS
#   variable for the (later) Wine compilation step. By default
#   this variable is set to: '-march=native -mtune=native'
#
function multilib_src_configure()
{
	(($# == 0)) || die "Invalid parameter count: ${#} (0)"

	printf "\\n\\n%s${FUNCNAME[ 0 ]} ()%s ... \\n" "${TTYWHITE_BOLD}" "${TTYRESET}"

	export	CFLAGS="${WINE_CFLAGS}"

	# Configure 64-bit wine64
	pushd_wrapper "${BUILD_ROOT}/wine64"
	[[ -f "Makefile" ]] && schroot_session_run "${SESSION_WINE64}" "${USERNAME}" "" \
								"make clean"
	schroot_session_run "${SESSION_WINE64}" "${USERNAME}" "" \
		"'${SOURCE_ROOT}/wine/configure' ${WINE_CONFIGURATION} --enable-win64 --prefix='${PREFIX}'"
	popd_wrapper

	# Configure 32-bit wine32_tools
	pushd_wrapper "${BUILD_ROOT}/wine32_tools"
	[[ -f "Makefile" ]] && schroot_session_run "${SESSION_WINE32}" "${USERNAME}" "" \
								"make clean"
	schroot_session_run "${SESSION_WINE32}" "${USERNAME}" "" \
		"'${SOURCE_ROOT}/wine/configure' ${WINE_CONFIGURATION} --prefix='${PREFIX}'"
	popd_wrapper
}

# function multilib_src_compile() [PHASE (4)]
#
# Parameters: <none>
#
# Description:
#   The multilib_src_compile() function compiles the following
#   Wine build directories:
#    1) wine64
#    2) wine32_tools
#   (in the specified order).
#
#   Finally the build directory:
#    3) wine32
#   is cleaned and configured, referencing the other two Wine
#   build directories.
#   The wine32 build directory is compiled last.
#
#   The global variable, WINE_MAKE_OPTIONS, is used to pass compilation
#   options to the chroot make call. By default this is only:
#     -j<threads>
#   where: threads='# system cpu threads'
#
# multilib_src_compile()
function multilib_src_compile()
{
	(($# == 0)) || die "Invalid parameter count: ${#} (0)"

	printf "\\n\\n%s${FUNCNAME[ 0 ]} ()%s ... \\n" "${TTYWHITE_BOLD}" "${TTYRESET}"

	# Build 64-bit wine64
	pushd_wrapper "${BUILD_ROOT}/wine64"
	schroot_session_run "${SESSION_WINE64}" "${USERNAME}" "" \
		"make ${WINE_MAKE_OPTIONS}"
	popd_wrapper

	# Build 32-bit wine32_tools
	pushd_wrapper "${BUILD_ROOT}/wine32_tools"
	schroot_session_run "${SESSION_WINE32}" "${USERNAME}" "" \
		"make ${WINE_MAKE_OPTIONS}"
	popd_wrapper

	# Configure & Build multilib wine32(64)
	pushd_wrapper "${BUILD_ROOT}/wine32"
	[[ -f "Makefile" ]] && schroot_session_run "${SESSION_WINE32}" "${USERNAME}" "" \
		"make clean"
	schroot_session_run "${SESSION_WINE32}" "${USERNAME}" "" \
		"'${SOURCE_ROOT}/wine/configure' ${WINE_CONFIGURATION} \
		--with-wine64='${BUILD_ROOT}/wine64' \
		--with-wine-tools='${BUILD_ROOT}/wine32_tools' \
		--prefix='${PREFIX}'" \
		"make ${WINE_MAKE_OPTIONS}"
	popd_wrapper
}

# function multilib_src_install() [PHASE (5)]
#
# Parameters: <none>
#
# Description:
#   The multilib_src_compile() function runs 'make install' in
#   the following Wine build directories:
#    1) wine32
#    2) wine64
#   (in the specified order). This step installs the 32-bit and 64-bit
#   (respectively) Wine builds, within the Schroot chroot
#   environments.
#
#   The build user's HOME directory is mounted,
#   and thereby shared, between the 32-bit and 64-bit Schroot chroot
#   environments. It is therefore recommended that a subdirectory, of
#   (the build user's) HOME directory, is used as the (global)
#   PREFIX Wine installation (root) directory.
#
# multilib_src_install()
function multilib_src_install()
{
	(($# == 0)) || die "Invalid parameter count: ${#} (0)"

	printf "\\n\\n%s${FUNCNAME[ 0 ]} ()%s ... \\n" "${TTYWHITE_BOLD}" "${TTYRESET}"

	# Clean install directory
	rm -rf "${PREFIX:?}/"* || die "rm failed"

	# Install Wine (32-bit) binaries in specified PREFIX path
	pushd_wrapper "${BUILD_ROOT}/wine32"
	schroot_session_run "${SESSION_WINE32}" "${USERNAME}" "" \
		"make install"
	popd_wrapper

	pushd_wrapper "${BUILD_ROOT}/wine64"
	# Install Wine (64-bit) binaries in specified PREFIX path
	schroot_session_run "${SESSION_WINE64}" "${USERNAME}" "" \
		"make install"
	popd_wrapper
}

#### Command line processing functions ####

# function screen_conf_file()
#
# Parameters:
#     1>  __script_conf_file  : global configuration file  (string)
#      <  0 = OK ; 1 = error
#
# Description:
#   This function uses awk (gawk) to parse the global configuration file
#   (__script_conf_file). The awk script checks the global configuration
#   file for errors or (potential) system exploits. Any configuration
#   lines with errors are displayed, with the syntax issues highlighted.
#   If an error is detected the function returns 1 (otherwise the
#   function returns 0).
#
function screen_conf_file()
{
	(($# == 1)) || die "Invalid parameter count: ${#} (1)"

	local __script_conf_file="${1}"

	[[ -z ${__script_conf_file} || ! -f "${__script_conf_file}" ]] \
		&& die "Script configuration file: \"${__script_conf_file}\" does not exist"

	# shellcheck disable=SC1004
	gawk 'BEGIN{
			regex_pre_whitespace="^[[:blank:]][[:blank:]]*"
			regex_post_whitespace="[[:blank:]][[:blank:]]*$"
			regex_blank_line="^[[:blank:]]*$"
			regex_blank_comment_line="^[[:blank:]]*([#]|$)"
			regex_comment="(\"[^\"]*\"|[^\"]*)[[:blank:]]*[#]"
			regex_boolean_variables="^(COLOR|COLOUR|LOGGING|WINE_ADDON_GLOBAL|WINE_STAGING)$"
			regex_string_variables="^((BUILD|SOURCE)_ROOT|"\
"LOG_(COMPRESSION|DIRECTORY)|PREFIX|THREADS|"\
"WINE_ADDON_(GLOBAL|RELPATH)|"\
"WINE_(CFLAGS|CONFIGURATION|MAKE_OPTIONS|VERSION|BRANCH|COMMIT)|"\
"WINE_STAGING_(BRANCH|COMMIT|EXCLUDE|VERSION)|"\
"WORKING_PATCHES_DIRECTORY)$"
			regex_array_string_variables="^(USER_PATCH_DIRECTORIES)$"
			regex_string_value="^\"[^\"]*\"$"
			regex_boolean_value="^(0|1|false|true|no|yes)"
			regex_array_string_value="^[(][[:blank:]]*(\"[^\"]*\"[[:blank:]]*)(\"[^\"]*\"[[:blank:]]*)*[)]$"
			regex_shell_command="[$][(][^)]*[)]"
			regex_operator="[+][=]|[-][=]|[=]"
			command_tput="tput setaf 1 ; tput bold"
			command_tput | getline ttyred_bold
			close(command_tput)
			command_tput="tput setab 1 ; tput bold"
			command_tput | getline ttyred_bold_background
			close(command_tput)
			command_tput="tput setaf 4"
			command_tput | getline ttyblue
			close(command_tput)
			command_tput="tput setaf 6 ; tput bold"
			command_tput | getline ttycyan_bold
			close(command_tput)
			command_tput="tput sgr0"
			command_tput | getline ttyreset
			close(command_tput)
		}
		{
			if ($0 ~ regex_blank_comment_line)
				next

			error=0
			pre_whitespace=post_whitespace=variable=operator=value=""
			i=0
			while (++i<=NF) {
				if ($i ~ regex_blank_line)
					continue

				variable=$i
				break
			}
			match(variable, regex_operator)
			if (RSTART) {
				operator=substr(variable, RSTART,RLENGTH)
				value=substr(variable, RSTART+RLENGTH)
				variable=substr(variable, 1, RSTART-1)
			}
			while (++i<=NF)
				value=(value " " $i)
			if (operator == "") {
				match(value, regex_operator)
				if (RSTART) {
					operator=substr(value, 1, RSTART+RLENGTH-1)
					value=substr(value, RSTART+RLENGTH)
				}
			}
			comment=""
			if (operator == "") {
				match(variable, "[#]")
				if (RSTART) {
					comment=(" " substr(variable, RSTART+RLENGTH-1))
					variable=substr(variable, 1, RSTART+RLENGTH-1)
				}
			}
			else {
				match(value, regex_comment)
				if (RSTART) {
					comment=(" " substr(value, RSTART+RLENGTH-1))
					value=substr(value, 1, RSTART+RLENGTH-2)
				}
			}
			sub(regex_pre_whitespace, "", variable)
			sub(regex_post_whitespace, "", value)
			match(variable, regex_post_whitespace)
			if (RSTART) {
				pre_whitespace=substr(variable, RSTART, RLENGTH)
				variable=substr(variable, 1, RSTART-1)
			}
			match(operator, regex_pre_whitespace)
			if (RSTART) {
				pre_whitespace=(pre_whitespace substr(operator, 1, RLENGTH))
				operator=substr(operator, RSTART+RLENGTH)
			}
			match(operator, regex_post_whitespace)
			if (RSTART) {
				post_whitespace=substr(operator, RSTART)
				operator=substr(operator, 1, RSTART-1)
			}
			match(value, regex_pre_whitespace)
			if (RSTART) {
				post_whitespace=(post_whitespace substr(value, 1, RLENGTH))
				value=substr(value, RSTART+RLENGTH)
			}
			value_valid=value_missing=operator_valid=operator_missing=variable_valid=0
			boolean_variable_valid=(variable ~ regex_boolean_variables)
			string_variable_valid=(variable ~ regex_string_variables)
			array_variable_valid=(variable ~ regex_array_string_variables)
			variable_valid=boolean_variable_valid || string_variable_valid || array_variable_valid

			if (operator == "") {
				if (boolean_variable_valid || string_variable_valid)
					operator="="
				else if (array_variable_valid)
					operator="[+]="
				operator_missing=1
			}
			else if (boolean_variable_valid || string_variable_valid)
				operator_valid=(operator == "=")
			else if (array_variable_valid)
				operator_valid=(operator == "+=") || (operator == "=")

			if (operator_valid && variable_valid) {
				value_valid=(boolean_variable_valid && (value ~ regex_boolean_value)) ||
							(string_variable_valid && (value ~ regex_string_value)) ||
						    (array_variable_valid && (value ~ regex_array_string_value))
			}
			if (variable_valid && (value == "")) {
				value="??"
				value_missing=1
			}

			if ((variable == "") && (operator == "") && (value == ""))
				value_valid=operator_valid=variable_valid=1

			if (!variable_valid)
				variable=(ttyred_bold variable ttyreset)
			if (!operator_valid)
				operator=((operator_missing ? ttyblue : ttyred_bold) operator ttyreset)
			if (!value_valid)
				value=((value_missing ? ttyblue : ttyred_bold) value ttyreset)
			if (gsub(regex_shell_command, (ttyred_bold "&" ttyreset), value))
				value_valid=0

			error=!(variable_valid && operator_valid && value_valid)
			error=error || pre_whitespace || post_whitespace
			if (pre_whitespace)
				pre_whitespace=(ttyred_bold_background pre_whitespace ttyreset)
			if (post_whitespace)
				post_whitespace=(ttyred_bold_background post_whitespace ttyreset)

			if (error) {
				printf("%s(%04d)%s %s%s%s%s%s%s\n",
					    ttycyan_bold, FNR, ttyreset,
						variable, pre_whitespace, operator, post_whitespace, value, comment)
			}
			invalid=invalid || error
		}
		END{
			exit invalid
		}' "${__script_conf_file}" #2>/dev/null

	return
}

# function process_command()
#
# Parameters:
#     1[-N]>  option  : script parameters  (string, array)
#
# Description:
#   This function parses all the command line arguments passed to the
#   main script:
#    1) all the option parameters are parsed initally
#    2) then checks are made for the command (or multiple commands)
#       that is (are) to be performed
#
#   This second phase sets the global variable COMMAND, as a function
#   side effect. This variable is used (later) by the function:
#   process_command() ; to actually execute the specified command(s).
#
#   Any invalid or unsupport option or command will result in a fatal
#   error. The offending parameter is displayed, as part of the resulting
#   error message.
#
#   Any command line specified options, which override a global configuration
#   variable, will take precedence over an assignment of that variable,
#   in the global script configuration file.
#
#   Incompatible situations are detected and cause a fatal error. E.g. trying
#   to chain together Schroot-setup/update commands with build options and/or
#   commands.
#
function process_command()
{
	# 1) Process options
	local option="${1}"
	local build_options directory directory_type log_compression parent_directory
	while (($#)); do
		case "${option}" in
			--build-directory|--build-dir|--log-directory|--log-dir|--patch-directory|--patch-dir|--source-directory|--source-dir|--prefix|--prefix-directory|--prefix-dir)
				directory_type=$(echo "${option}" | sed -r 's:(^[-][-]|[-]directory$|[-]dir$)::g')
				[[ "${directory_type}" != "log" ]] && build_options="${build_options} ${option}"
				shift
 				(($#)) ||	 die "invalid option syntax: ${directory_type} directory not specified" "" 1
				directory=$(readlink -f "${1}")
				parent_directory="$(dirname "${directory}")"
				[[ -d "${parent_directory}" ]] || die "${directory_type} directory parent: \"{parent_directory}\" does exist"
				case "${directory_type}" in
					build)		export BUILD_ROOT="${directory}";;
					log)		export LOG_DIRECTORY="${directory}";;
					patch)		export USER_PATCH_DIRECTORIES[${#USER_PATCH_DIRECTORIES[@]}]="${directory}";;
					source)		export SOURCE_ROOT="${directory}";;
					prefix)		export PREFIX="${directory}";;
				esac
				;;

			-c=*|--color=*|--colour=*)
				parse_boolean_option "${option#*=}" "COLOUR"
				setup_tty_colours "${COLOUR}"
				;;

			-c|--color|--colour)
				shift
 				(($#)) ||	die "invalid option syntax: no colour option specified" "" 1
				parse_boolean_option "${1}" "COLOUR"
				setup_tty_colours "${COLOUR}"
				;;

			--logging=*|--log=*)
				parse_boolean_option "${option#*=}" "LOGGING"
				;;

			--logging|--log)
				shift
 				(($#)) ||	die "invalid option syntax: no logging option specified" "" 1
				parse_boolean_option "${1}" "LOGGING"
				;;

			--log-compression=*)
				log_compression="${option#*=}"
				[[ -n "${log_compression}" ]] || log_compression="none"
				set_log_compression "${log_compression}"
				;;

			--log-compression)
				shift
				log_compression="none"
				(($#)) && log_compression="${1}"
				set_log_compression "${log_compression}"
				;;

			--wine-staging-branch=*|--wine-staging-commit=*)
				build_options="${build_options} ${option%=*}"
				[[ "${option%=*}" =~ branch$ ]] && WINE_STAGING_BRANCH="${option#*=}"
				[[ "${option%=*}" =~ commit$ ]] && WINE_STAGING_COMMIT="${option#*=}"
				;;

			--wine-staging-branch|--wine-staging-commit)
				build_options="${build_options} ${option}"
				shift
				(($#)) || die "invalid option syntax: Wine-Staging ${option##*-} not specified" "" 1
				[[ "${option}" =~ branch$ ]] && WINE_STAGING_BRANCH="${1}"
				[[ "${option}" =~ commit$ ]] && WINE_STAGING_COMMIT="${1}"
				;;

			--wine-staging-version=*)
				build_options="${build_options} ${option%=*}"
				WINE_STAGING_VERSION="${option#*=}"
				;;

			--wine-staging-version)
				build_options="${build_options} ${option}"
				shift
				if (($#==0)); then
					die "invalid option syntax: Wine-Staging version not specified" "" 1
				fi
				WINE_STAGING_VERSION="${1}"
				;;

			--wine-branch=*|--wine-commit=*)
				build_options="${build_options} ${option%=*}"
				[[ "${option%=*}" =~ branch$ ]] && WINE_BRANCH="${option#*=}"
				[[ "${option%=*}" =~ commit$ ]] && WINE_COMMIT="${option#*=}"
				;;

			--wine-branch|--wine-commit)
				build_options="${build_options} ${option}"
				shift
				(($#)) || die "invalid option syntax: Wine ${option##*-} not specified" "" 1
				[[ "${option}" =~ branch$ ]] && WINE_BRANCH="${1}"
				[[ "${option}" =~ commit$ ]] && WINE_COMMIT="${1}"
				;;

			--wine-staging=*|--staging=*)
				build_options="${build_options} ${option%=*}"
				parse_boolean_option "${option#*=}" "WINE_STAGING"
				;;

			--wine-staging|--staging)
				build_options="${build_options} ${option}"
				shift
 				(($#)) || die "invalid option syntax: Wine-Staging option not specified ([yes|no])" "" 1
				parse_boolean_option "S{1}" "WINE_STAGING"
				;;

			--wine-version=*)
				build_options="${build_options} ${option%=*}"
				WINE_VERSION="${option#*=}"
				;;

			--wine-version)
				build_options="${build_options} ${option}"
				shift
				if (($#==0)); then
					die "invalid option syntax: Wine version not specified" "" 1
				fi
				WINE_VERSION="${1}"
				;;

			--)
				unset -v option
				shift
				break 2
				;;

			--*)
				die "unknown option specified: \"${option}\"" "" 1
				;;

			*)
				unset -v option
				break 2
				;;
		esac
		if [[ -n "${option}" ]]; then
			shift
			option="${1}"
		fi
	done
	build_options="${build_options:1}"

	# 2) Process commands
 	(($# < 1)) &&	die "no command specified" "" 1
	for ((i=SRC_FETCH; i<=SRC_INSTALL; ++i)); do
		SUBCOMMANDS[i]=0
	done
	local	new_command prev_command
	while (( $# > 0 )); do
		new_command="${1}"
		case "${new_command}" in

		help|h)
			usage_information >&2
			exit 0
			;;

		generate-conf|conf)
			if [[ -n "${COMMAND}" ]]; then
				die "incompatible command(s) specified : \"${prev_command}\" \"${new_command}\"" "" 1
			elif [[ -n "${build_options}" ]]; then
				die "build-option(s): \"${build_options}\" ; are incompatible with command: \"${new_command}\"" "" 1
			fi
			export	COMMAND="conf"
			;;

		setup-chroot|setup)
			if [[ -n "${COMMAND}" ]]; then
				die "incompatible command(s) specified : \"${prev_command}\" \"${new_command}\"" "" 1
			elif [[ -n "${build_options}" ]]; then
				die "build-option(s): \"${build_options}\" ; are incompatible with command: \"${new_command}\"" "" 1
			fi
			export	COMMAND="setup"
			;;

		upgrade-chroot|upgrade|update-chroot|update)
			if [[ -n "${COMMAND}" ]]; then
				die "incompatible command(s) specified : \"${prev_command}\" \"${new_command}\""  "" 1
			elif [[ -n "${build_options}" ]]; then
				die "build-option(s): \"${build_options}\" ; are incompatible with command: \"${new_command}\"" "" 1
			fi
			export	COMMAND="upgrade"
			;;

		version)
			if [[ -n "${COMMAND}" ]]; then
				die "incompatible command(s) specified : \"${prev_command}\" \"${new_command}\""  "" 1
			elif [[ -n "${build_options}" ]]; then
				die "build-option(s): \"${build_options}\" ; are incompatible with command: \"${new_command}\"" "" 1
			fi
			export	COMMAND="version"
			;;

		src-fetch|src-prepare|src-configure|src-compile|src-install|build|build-all)
			if ((WINE_STAGING)); then
				git_get_branch_list "wine-staging" "WINE_STAGING_BRANCH_ARRAY"
				if ((! ${#WINE_STAGING_BRANCH_ARRAY[@]})); then
					WINE_STAGING_BRANCH_ARRAY=( "origin/master" )
				fi
				set_wine_staging_git_tag
			else
				git_get_branch_list "wine" "WINE_BRANCH_ARRAY"
				if ((! ${#WINE_BRANCH_ARRAY[@]})); then
					WINE_BRANCH_ARRAY=( "origin/master" "origin/oldstable" "origin/stable" )
				fi
				set_wine_git_tag
			fi

			if [[ "${COMMAND}" =~ setup|upgrade ]]; then
				die "incompatible command(s) specified : \"${prev_command}\" \"${new_command}\"" "" 1
			fi
			export	COMMAND="build"
			case "${new_command}" in
				src-fetch)
					SUBCOMMANDS[SRC_FETCH]=1;;
				src-prepare)
					SUBCOMMANDS[SRC_PREPARE]=1;;
				src-configure)
					SUBCOMMANDS[SRC_CONFIGURE]=1;;
				src-compile)
					SUBCOMMANDS[SRC_COMPILE]=1;;
				src-install)
					SUBCOMMANDS[SRC_INSTALL]=1;;
				build|build-all)
					for ((i=SRC_FETCH; i<=SRC_INSTALL; ++i)); do
						SUBCOMMANDS[i]=1
					done;;
			esac
			;;

		*)
			die "unknown command specified: \"${new_command}\""  "" 1
			;;

		esac
		prev_command="${new_command}"
		shift 1
	done
}

# function execute_commands()
#
# Parameters: <none>
#
# Description:
#   This function commands enumerates the value set in the global variable:
#   COMMAND ; and performs this operation. The 'build' command is unique in
#   that this allows individual build phases to be custom chained together.
#   The build phases, to be executed, are determined by the: SUBCOMMANDS ;
#   global variable. The 'build' command also calls some ancillary functions,
#   in addition to main the build phase functions, e.g. installing the
#   wine-gecko and wine-mono packages, etc.
#
#   Any command, with multiple function calls, runs this calls in a subblock,
#   redirecting shell output to the logging thread (via a FIFO pipe).
#
function execute_commands()
{
	(($# == 0)) || die "Invalid parameter count: ${#} (0)"

	case "${COMMAND}" in
	conf)
		export DATE_STAMP
		DATE_STAMP="$(date)"
		printf "\\n%s\\n" "${TTYWHITE}Generating default configuration file: \"${TTYCYAN_BOLD}${SCRIPT_CONFIG}${TTYRESET}${TTYWHITE}\"${TTYRESET} ..."
		export wine_staging_enabled
		((WINE_STAGING)) && wine_staging_enabled="true"
		((WINE_STAGING)) || wine_staging_enabled="false"
		(
			cat <<EOF_script_config
#
# ${SCRIPT_CONFIG} - Configuration file for ${SCRIPT_NAME}
#
# Generated by ${SCRIPT_NAME} (${BUILD_MULTILIB_WINE_VERSION}) on ${DATE_STAMP} (build version: ${BUILD_MULTILIB_WINE_VERSION})
#
# Uncomment the default, example options and change these as desired.
#
# Global
#
# Colourise all terminal/logging output ; 1=enabled 0=disabled
# COLOUR=${COLOUR} # default
#
# Directories
#
# Installation prefix directory in which Wine libraries, binaries, etc. are installed.
# PREFIX="${PREFIX}" # default
#
# Root directory where sources are stored i.e. clones of Wine (and Wine-Staging) Git trees.
# SOURCE_ROOT="${SOURCE_ROOT}" # default
#
# Root directory where the binary builds are stored - "out-of-tree" build.
# BUILD_ROOT="${BUILD_ROOT}" # default
#
# Internal storage for patches
# WORKING_PATCHES_DIRECTORY="${WORKING_PATCHES_DIRECTORY}" # default
#
# Patch files (in -p1 diff format), in these directories, are applied to the Wine source.
# USER_PATCH_DIRECTORIES=( "dir1" )
# USER_PATCH_DIRECTORIES+=( "dir2" "dir3" )
#
# Wine storage path for addons: wine-gecko wine-mono
# WINE_ADDON_GLOBAL=${WINE_ADDON_GLOBAL} # default
# ... WINE_ADDON_GLOBAL=1 : "${HOME%/}${WINE_ADDON_GLOBAL_RELPATH%/}"
# ... WINE_ADDON_GLOBAL=0 : "${PREFIX%/}/${WINE_ADDON_RELPATH#/}"
# WINE_ADDON_GLOBAL_RELPATH=${WINE_ADDON_GLOBAL_RELPATH} # default
# WINE_ADDON_RELPATH="${WINE_ADDON_RELPATH}" # default
#
# Versioning
#
# Enable / disable Wine-Staging patchset support.
# WINE_STAGING=${wine_staging_enabled} # default
#
# Wine version to build.
# WINE_VERSION="4.11"
#
# Git branch of Wine to build (WINE_STAGING=no).
# WINE_BRANCH="refs/heads/master"
#
# Git commit (SHA-1 hash) of Wine to build (WINE_STAGING=no).
# WINE_COMMIT=""
#
# Git branch of Wine-Staging to build (WINE_STAGING=yes).
# WINE_STAGING_BRANCH="refs/heads/master"
#
# Git commit (SHA-1 hash) of Wine-Staging to build (WINE_STAGING=yes).
# WINE_STAGING_COMMIT=""
#
# Wine-Staging version to build.
# WINE_STAGING_VERSION="4.11"
#
# Logging
#
# Enable / disable operation logging for commands: setup-chroot; upgrade-chroot; build-all (and sub-phases).
# LOGGING=1 # default
#
# Directory to hold log files - recording all the script operations.
# LOG_DIRECTORY="${LOG_DIRECTORY}" # default
#
# Compression to be applied to new log files.
# LOG_COMPRESSION="xz" # default
#
#
# Building
#
# Number of processor threads to use.
# THREADS="${THREADS}" # default
#
# Wine-Staging subpatchsets to optionally disable.        [src-prepare]
# WINE_STAGING_EXCLUDE="" # default
#
# Configuration options for wine.                         [src-configure]
# WINE_CONFIGURATION="${WINE_CONFIGURATION}" # default
#
# CFLAGS (compile flags) to pass to wine.                 [src-configure]
# WINE_CFLAGS="${WINE_CFLAGS}" # default
#
# Make options to use when compiling wine.                [src-compile]
# WINE_MAKE_OPTIONS="${WINE_MAKE_OPTIONS}" # default
#
#
# OS Version Override (e.g. cross-building for another Debian / Ubuntu version)
# LSB_CODENAME="" # default: lsb_release -sc
EOF_script_config
		)> "${SCRIPT_CONFIG}" \
		|| die "Failed to generate default configuration file: \"${SCRIPT_CONFIG}\""
		;;
	setup)
		if [[ -n "${OPTIONS}" ]]; then
			die "invalid option(s) specified: ${OPTIONS}" "" 1
		fi
		setup_logging "${COMMAND}"
		{
			export -f schroot_session_start schroot_session_run schroot_session_cleanup \
						cleanup die get_optimum_repository_mirror schroot_image_bootstrap \
						setup_chroot_build_env upgrade_chroot_build_env

			printf "\\n%s\\n" "${TTYWHITE}Please enter your ${TTYRED}root${TTYRESET}${TTYWHITE} user password when prompted (${TTYCYAN_BOLD}not your sudo password!${TTYRESET}${TTYWHITE})${TTYRESET}"
			# shellcheck disable=SC2016
			su -p -c '
				printf "\\n%sDetecting optimal %s Mirror%s ...\\n" "${TTYWHITE_BOLD}" "${LSB_DISTRIBUTION_ID^}" "${TTYRESET}"
				export		REPOSITORY_MIRROR_URI
				get_optimum_repository_mirror REPOSITORY_MIRROR_URI
				printf "\\n%sCreating 32-bit Chroot Environment%s ...\\n" "${TTYWHITE_BOLD}" "${TTYRESET}"
				schroot_image_bootstrap "'"${LSB_CODENAME}_wine_32bit"'" "i386"
				printf "\\n%sCreating 64-bit Chroot Environment%s ...\\n" "${TTYWHITE_BOLD}" "${TTYRESET}"
				schroot_image_bootstrap "'"${LSB_CODENAME}_wine_64bit"'" "amd64"
				printf "\\n%sInstalling %s image to 32-bit Chroot Environment%s ...\\n" "${TTYWHITE_BOLD}" "${LSB_DISTRIBUTION_ID^}" "${TTYRESET}"
				setup_chroot_build_env "'"${LSB_CODENAME}_wine_32bit"'"
				printf "\\n%sInstalling %s image to 64-bit Chroot Environment%s ...\\n" "${TTYWHITE_BOLD}" "${LSB_DISTRIBUTION_ID^}" "${TTYRESET}"
				setup_chroot_build_env "'"${LSB_CODENAME}_wine_64bit"'"
				printf "\\n%sInstall Updated Wine Development packages to 32-bit Chroot Environment%s ...\\n" "${TTYWHITE_BOLD}" "${TTYRESET}"
				upgrade_chroot_build_env "'"${LSB_CODENAME}_wine_32bit"'"
				printf "\\n%sInstall Updated Wine Development packages to 64-bit Chroot Environment%s ...\\n" "${TTYWHITE_BOLD}" "${TTYRESET}"
				upgrade_chroot_build_env "'"${LSB_CODENAME}_wine_64bit"'"
			' root || die "Failed to setup Chroot environments"
		} &>"${__FIFO_LOG_PIPE}"
		;;
	upgrade)
		setup_logging "${COMMAND}"
		{
			export -f schroot_session_start schroot_session_run schroot_session_cleanup \
						cleanup die upgrade_chroot_build_env
			local chroot_name found32bit_chroot=0 found64bit_chroot=0

			while read -r chroot_name; do
				[[ "${chroot_name}" == "${CHROOT32_NAME}" ]] && found32bit_chroot=1
				[[ "${chroot_name}" == "${CHROOT64_NAME}" ]] && found64bit_chroot=1
			done < <(schroot -l)
			if ((!found32bit_chroot && !found64bit_chroot)); then
				if ((!found32bit_chroot)); then
					printf "%sChroot Environment%s: \"%s${CHROOT32_NAME}%s\"%s ; has not yet been created.%s\\n" \
							"${TTYRED_BOLD}" "${TTYRESET}" "${TTYWHITE_BOLD}" "${TTYRESET}" "${TTYRED_BOLD}" >&2
				fi
				if ((!found64bit_chroot)); then
					printf "%sChroot Environment%s: \"%s${CHROOT64_NAME}%s\"%s ; has not yet been created.%s\\n" \
							"${TTYRED_BOLD}" "${TTYRESET}" "${TTYWHITE_BOLD}" "${TTYRESET}" "${TTYRED_BOLD}" >&2
				fi
				die "Please run: \"${SCRIPT_NAME} setup-chroot\" ; initially - to setup Chroot Environments"
			fi

			printf "\\n%s\\n" "${TTYWHITE}Please enter your ${TTYRED}root${TTYRESET}${TTYWHITE} user password when prompted (${TTYCYAN_BOLD}not your sudo password!${TTYRESET}${TTYWHITE})${TTYRESET}"
			# shellcheck disable=SC2016
			su -p -c '
				printf "\\n${TTYWHITE_BOLD}Upgrade Wine Development packages in 32-bit Chroot Environment${TTYRESET} ...\\n"
				upgrade_chroot_build_env ''"${LSB_CODENAME}_wine_32bit"''
				printf "\\n${TTYWHITE_BOLD}Upgrade Wine Development packages in 64-bit Chroot Environment${TTYRESET} ...\\n"
				upgrade_chroot_build_env ''"${LSB_CODENAME}_wine_64bit"''
			' root || die "Failed to upgrade Chroot environments"
		} &>"${__FIFO_LOG_PIPE}"
		;;
	version)
		printf "\\n%s${SCRIPT_NAME} version%s: %s${BUILD_MULTILIB_WINE_VERSION}%s ...\\n" \
				"${TTYCYAN}" "${TTYRESET}" "${TTYWHITE_BOLD}" "${TTYRESET}"
		;;
	build)
		setup_logging "${COMMAND}"
		{
			create_main_directories "${SOURCE_ROOT}" \
				"${BUILD_ROOT}/wine32" "${BUILD_ROOT}/wine32_tools" "${BUILD_ROOT}/wine64"
			if ((SUBCOMMANDS[SRC_PREPARE]
				|| SUBCOMMANDS[SRC_CONFIGURE]
				|| SUBCOMMANDS[SRC_COMPILE]
				|| SUBCOMMANDS[SRC_INSTALL])); then
				schroot_session_start "${SESSION_WINE32}" "${USERNAME}" "${CHROOT32_NAME}"
				schroot_session_start "${SESSION_WINE64}" "${USERNAME}" "${CHROOT64_NAME}"
			fi
			fetch_wine_staging_patchbin_script "${SOURCE_ROOT}"
			((SUBCOMMANDS[SRC_FETCH]))		&& src_fetch
			if ((WINE_STAGING)); then
				git_get_tag "wine-staging" "__WINE_STAGING_VERSION"
				export __WINE_STAGING_VERSION="${__WINE_STAGING_VERSION#${WINE_STAGING_PREFIX}}"
				git_get_commit "wine-staging" "__WINE_STAGING_COMMIT"
			fi
			git_get_tag "wine" "__WINE_VERSION"
			export __WINE_VERSION="${__WINE_VERSION#${WINE_PREFIX}}"
			git_get_commit "wine" "__WINE_COMMIT"
			((SUBCOMMANDS[SRC_PREPARE]))	&& src_prepare
			((SUBCOMMANDS[SRC_CONFIGURE]))	&& multilib_src_configure
			((SUBCOMMANDS[SRC_COMPILE]))	&& multilib_src_compile
			if ((SUBCOMMANDS[SRC_INSTALL])); then
				multilib_src_install
				# shellcheck disable=SC2068
				install_wine_addon "gecko"
				# shellcheck disable=SC2068
				install_wine_addon "mono"
			fi
		} &>"${__FIFO_LOG_PIPE}"
		[[ -f "${SOUND_COMPLETION}" ]] && paplay "${SOUND_COMPLETION}" &>"/dev/null"
		;;
	esac
}

# function main()
#
# Parameters: <none>
#
# Description:
#   This function wraps the main setup operations,
#   command/option processing, command execution and
#   cleanup functions for the build script.
#
#   Global variables are setup. This includes a check for a
#   global script configuration file.
#
#   A logging FIFO pipe is created and log compression is
#   set. NOTE: the actual logging thread is not created
#   (or necessary) at this point.
#
#   The build script is set to a very low (background) process
#   priority (aka a high nice value).
#
#   The function trap_exit() is setup as a global trap call
#   for the build script. This allows a more graceful cleanup,
#   e.g. when the end-user enters CTRL-C', when a Wine build
#   is running, etc.
#
#   Any pre-existing Schroot sessions, with name collisions,
#   are ended.
#
#   Command line arguments are processed.
#
#   Package dependencies are checked.
#
#   The specified end-user command(s) are executed.
#
#   Finally some cleanup is carried out (when the script
#   terminates without any errors).
#
function main()
{
	export		BUILD_MULTILIB_WINE_VERSION SCRIPT_DIRECTORY SCRIPT_NAME SCRIPT_PID SCRIPT_PATH

	BUILD_MULTILIB_WINE_VERSION="20190605"
	SCRIPT_PID=$$
	SCRIPT_PATH="$(readlink -f "${0}")"
	SCRIPT_DIRECTORY="$(dirname "${SCRIPT_PATH}")"
	SCRIPT_NAME="$(basename "${SCRIPT_PATH}")"


	# Script directories and configuration files
	export		SCRIPT_CACHE_DIRECTORY SCRIPT_CONFIG_DIRECTORY SCRIPT_CONFIG
	SCRIPT_CONFIG_DIRECTORY="${HOME%/}/.config/${SCRIPT_NAME}/"
	SCRIPT_CONFIG="${SCRIPT_CONFIG_DIRECTORY%/}/${SCRIPT_NAME}.conf"
	SCRIPT_CACHE_DIRECTORY="${HOME%/}/.cache/${SCRIPT_NAME}/"
	mkdir -p "${SCRIPT_CONFIG_DIRECTORY}" \
		|| die "Failed to create script directory: '${SCRIPT_CONFIG_DIRECTORY}'"
	mkdir -p "${SCRIPT_CACHE_DIRECTORY}" \
		|| die "Failed to create cache directory: '${SCRIPT_CACHE_DIRECTORY}'"

	declare -a	USER_PATCH_DIRECTORIES
	export  USER_PATCH_DIRECTORIES

	# Global versioning constants
	export	WINE_STAGING="${WINE_STAGING:-0}"
	export	WINE_VERSION WINE_STAGING_VERSION
	export	WINE_BRANCH_ARRAY WINE_STAGING_BRANCH_ARRAY
	export	WINE_BRANCH WINE_STAGING_BRANCH
	export	WINE_COMMIT WINE_STAGING_COMMIT

	# Global patch constants
	# shellcheck disable=SC2031
	export  WINE_STAGING_EXCLUDE

	# Read in main parameters from global .conf file for script (default: /etc/build_multilib_wine.conf)
	if [[ -f "${SCRIPT_CONFIG}" ]]; then
		if ! screen_conf_file "${SCRIPT_CONFIG}"; then
			die "invalid lines detected in configuration file \"${SCRIPT_CONFIG}\""
		else
			# shellcheck disable=SC1090
			. "${SCRIPT_CONFIG}"
		fi
	fi

	#### Global Environment Variable defaults ####

	# Global general
	export		COLOUR
	COLOUR="${COLOUR:-${COLOR:-0}}"

	parse_boolean_option "${COLOUR}" "COLOUR"
	setup_tty_colours "${COLOUR}"
	if (( EUID == 0 )); then
			die "do not run this script as root - you will asked for full root privileges as required!!"
	else
		printf "%s\\n" "${TTYRED_BOLD}warning${TTYRESET}: ${TTYCYAN_BOLD}this script may require to run as ${TTYRED}root${TTYRESET} - ${TTYCYAN_BOLD}you must therefore have a ${TTYRED}root${TTYCYAN_BOLD} password set${TTYRESET}..."
	fi
	if [[ -f "${SCRIPT_CONFIG}" ]]; then
		printf "Read global configuration file: \"%s\"...\\n" "${TTYBLUE_BOLD}${SCRIPT_CONFIG}${TTYRESET}"
	fi
	# Global name constants
	export 	GENTOO_WINE_EBUILD_COMMON_PACKAGE="gentoo-wine-ebuild-common"

	# Global versioning defaults
	parse_boolean_option "${WINE_STAGING}" "WINE_STAGING"
	export		__WINE_COMMIT	__WINE_STAGING_COMMIT
	export		__WINE_VERSION	__WINE_STAGING_VERSION

	# Global script constants
	export	WINE_STAGING_PATCHBIN_SCRIPT="patchbin.sh"
	export	WINE_STAGING_PATCHINSTALL_SCRIPT="patches/patchinstall.sh"
	export	SOUND_COMPLETION="/usr/share/sounds/freedesktop/stereo/complete.oga"

	# Global versioning constants
	export	SHA1_REGEXP="^[[:xdigit:]]{40}$"
	export	VARIABLE_NAME_REGEXP="^[_[:alpha:]][_[:alnum:]]+$"
	export	VERSION_REGEXP="^[[:digit:]]{1,2}[.][[:digit:]]{1,2}([.][[:digit:]]{1,2}|)([-]rc[[:digit:]]{1}|)$"
	export	STABLE_VERSION_REGEXP="^1\\.8\\.[[:digit:]]{1,2}$"
	export	WINE_STAGING_PREFIX="v"
	export	WINE_STAGING_SUFFIX="-unofficial"
	export	WINE_PREFIX="wine-"
	export	GENTOO_WINE_EBUILD_COMMON_PACKAGE_VERSION="20200605"

	# Global URI constants
	export	WINE_STAGING_GIT_URI="https://github.com/wine-staging/wine-staging.git"
	export	WINE_GIT_URI="git://source.winehq.org/git/wine.git"
	export	WINE_ADDON_URI="http://dl.winehq.org/wine/"
	export	GENTOO_WINE_EBUILD_COMMON_PACKAGE_URI="https://github.com/bobwya/${GENTOO_WINE_EBUILD_COMMON_PACKAGE}/archive/${GENTOO_WINE_EBUILD_COMMON_PACKAGE_VERSION}.tar.gz"
	export	WINE_STAGING_BINPATCH_URI="https://raw.githubusercontent.com/wine-staging/wine-staging/master/patches/gitapply.sh"
	export	WINE_STAGING_COMMIT_c48811407e3_URI="https://github.com/wine-staging/wine-staging/commit/c48811407e3c9cb2d6a448d6664f89bacd9cc36f.patch"
	export	WINE_EBUILD_COMMON="${GENTOO_WINE_EBUILD_COMMON_PACKAGE}-${GENTOO_WINE_EBUILD_COMMON_PACKAGE_VERSION}"

	if ((WINE_STAGING)); then
		set_wine_staging_git_tag 0
		export	__WINE_STAGING_GIT_TAG
	else
		set_wine_git_tag 0
		export	__WINE_GIT_TAG
	fi

	# Global build options and directory defaults
	if [[ -z "${THREADS}" ]]; then
		export THREADS
		THREADS="$(gawk '{ threads+=($0 ~ "^processor") }END{ print threads+1 }' /proc/cpuinfo)"
	fi
	export		PREFIX="${PREFIX:-${HOME}/usr}"
	export		SOURCE_ROOT="${SOURCE_ROOT:-${HOME}/Wine/Source}"
	export		WORKING_PATCHES_DIRECTORY="${WORKING_PATCHES_DIRECTORY:-${SOURCE_ROOT}/patches}"
	export		BUILD_ROOT="${BUILD_ROOT:-${HOME}/Wine/Build}"
	export		LOG_DIRECTORY="${LOG_DIRECTORY:-${BUILD_ROOT}/Logs}"
	export		WINE_CONFIGURATION="${WINE_CONFIGURATION:---without-hal --without-v4l --without-oss}"
	export		WINE_CFLAGS="${WINE_CFLAGS:--march=native -mtune=native}"
	export		WINE_MAKE_OPTIONS="${WINE_MAKE_OPTIONS:--j${THREADS}}"
	export		WINE_ADDON_GLOBAL="${WINE_ADDON_GLOBAL:-0}"
	export		WINE_ADDON_GLOBAL_RELPATH="/.local/share/wine"
	export		WINE_ADDON_RELPATH="${WINE_ADDON_RELPATH:-/share/wine}"

	# Supplemental patches, etc.
	export WINE_STAGING_COMMIT_c48811407e3_PATCH="wine-staging-eventfd_synchronization_fix_c48811407e3.patch"
	export EVENTFD_BROKEN_DIR_CHANGE_NOTIFICATION_COMMIT_RANGE=(
		"f883c66e40ada01c4413c5f33912339f88bd8073" "c48811407e3c9cb2d6a448d6664f89bacd9cc36f"
	)

	# Setup LSB codename / distribution ID for the chroot distribution
	export		LSB_CODENAME LSB_DISTRIBUTION_ID
	set_lsb_codename
	set_lsb_distribution_id

	# Global schroot constants
	export		DEBIAN_FRONTEND="noninteractive"
	export		CHROOT32_NAME="chroot:${LSB_CODENAME}_wine_32bit"
	export		CHROOT64_NAME="chroot:${LSB_CODENAME}_wine_64bit"
	export		SESSION_WINE_INITIALISE="session:wine_initialise"
	export		SESSION_WINE32="session:wine32"
	export		SESSION_WINE64="session:wine64"
	export 		USERNAME="${USER}"

	# Global build phase constants
	export	SRC_FETCH=1 SRC_PREPARE=2 SRC_CONFIGURE=3 SRC_COMPILE=4 SRC_INSTALL=5

	# Global logging constants
	export 		LOGGING="${LOGGING:-1}"
	parse_boolean_option "${LOGGING}" "LOGGING"
	export		__FIFO_LOG_PIPE
	export		__LOGGING_PID
	__FIFO_LOG_PIPE="$( mktemp -u )"

	# Run whole process set at lowest priority
	renice +19 -p $$ &>/dev/null

	# Cleanup after ourselves with function cleanup()
	# shellcheck disable=SC2173
	trap "trap_exit" ABRT INT QUIT TERM KILL STOP

	# Cleanup any remaining schroot sessions from previous run
	schroot -e -c "${SESSION_WINE_INITIALISE}" &>/dev/null
	schroot -e -c "${SESSION_WINE32}" &>/dev/null
	schroot -e -c "${SESSION_WINE64}" &>/dev/null

	# Process script parameters: options and commands
	# shellcheck disable=SC2153
	if [[ -n "${LOG_COMPRESSION}" ]]; then
		set_log_compression "${LOG_COMPRESSION}"
	elif command -v xz &>/dev/null; then
		set_log_compression "xz"
	elif command -v gzip &>/dev/null; then
		set_log_compression "gzip"
	else
		set_log_compression "none"
	fi
	process_command	"${@}"
	check_package_dependencies
	execute_commands

	display_completion_message

	cleanup
}


#### Global Block ####

main "${@}"

exit 0
